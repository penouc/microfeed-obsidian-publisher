/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/twitterClient.ts
var twitterClient_exports = {};
__export(twitterClient_exports, {
  TwitterClient: () => TwitterClient
});
var import_obsidian2, TwitterClient;
var init_twitterClient = __esm({
  "src/twitterClient.ts"() {
    import_obsidian2 = require("obsidian");
    TwitterClient = class {
      constructor(settings) {
        this.baseUrl = "https://api.twitter.com/2";
        this.settings = settings;
      }
      isConfigured() {
        return !!(this.settings.apiKey && this.settings.apiSecret && this.settings.accessToken && this.settings.accessTokenSecret && this.settings.bearerToken);
      }
      async postTweet(text) {
        if (!this.isConfigured()) {
          throw new Error("Twitter API credentials are not configured");
        }
        try {
          const response = await (0, import_obsidian2.requestUrl)({
            url: `${this.baseUrl}/tweets`,
            method: "POST",
            headers: {
              "Authorization": `Bearer ${this.settings.bearerToken}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              text
            })
          });
          if (response.status < 200 || response.status >= 300) {
            throw new Error(`Twitter API error: ${response.status} ${response.text}`);
          }
          return response.json;
        } catch (error) {
          console.error("Error posting to Twitter:", error);
          throw error;
        }
      }
      async testConnection() {
        if (!this.isConfigured()) {
          return false;
        }
        try {
          const response = await (0, import_obsidian2.requestUrl)({
            url: `${this.baseUrl}/users/me`,
            method: "GET",
            headers: {
              "Authorization": `Bearer ${this.settings.bearerToken}`
            }
          });
          return response.status >= 200 && response.status < 300;
        } catch (error) {
          console.error("Twitter connection test failed:", error);
          return false;
        }
      }
      formatTweetText(title, url, summary) {
        let tweet = "";
        switch (this.settings.postFormat) {
          case "title_only":
            tweet = title;
            break;
          case "title_with_link":
            tweet = `${title} ${url}`;
            break;
          case "title_with_summary":
            const truncatedSummary = summary ? this.truncateText(summary, 100) : "";
            tweet = `${title}

${truncatedSummary}
${url}`;
            break;
        }
        if (this.settings.includeHashtags && this.settings.customHashtags) {
          const hashtags = this.settings.customHashtags.split(",").map((tag) => tag.trim()).filter((tag) => tag.startsWith("#")).join(" ");
          if (hashtags) {
            tweet += ` ${hashtags}`;
          }
        }
        return this.truncateText(tweet, 280);
      }
      truncateText(text, maxLength) {
        if (text.length <= maxLength) {
          return text;
        }
        return text.substring(0, maxLength - 3) + "...";
      }
    };
  }
});

// src/styleManager.ts
var styleManager_exports = {};
__export(styleManager_exports, {
  DESIGN_STYLES: () => DESIGN_STYLES,
  getRandomStyle: () => getRandomStyle,
  getStyleById: () => getStyleById
});
function getRandomStyle() {
  const randomIndex = Math.floor(Math.random() * DESIGN_STYLES.length);
  return DESIGN_STYLES[randomIndex];
}
function getStyleById(id) {
  return DESIGN_STYLES.find((style) => style.id === id);
}
var DESIGN_STYLES;
var init_styleManager = __esm({
  "src/styleManager.ts"() {
    DESIGN_STYLES = [
      {
        id: "minimalist",
        name: "\u6781\u7B80\u4E3B\u4E49\u98CE\u683C",
        description: "\u91C7\u7528\u6781\u7B80\u4E3B\u4E49\u98CE\u683C\u8BBE\u8BA1\uFF0C\u9075\u5FAA'\u5C11\u5373\u662F\u591A'\u7684\u7406\u5FF5",
        colors: {
          primary: "#000000",
          secondary: "#666666",
          accent: "#f8f9fa",
          background: "#ffffff",
          text: "#333333"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["subtle-shadow", "clean-lines", "negative-space"]
      },
      {
        id: "bold-modern",
        name: "\u5927\u80C6\u73B0\u4EE3\u98CE\u683C",
        description: "\u91C7\u7528\u5927\u80C6\u73B0\u4EE3\u98CE\u683C\u8BBE\u8BA1\uFF0C\u6253\u7834\u4F20\u7EDF\u6392\u7248\u89C4\u5219\uFF0C\u521B\u9020\u5F3A\u70C8\u89C6\u89C9\u51B2\u51FB",
        colors: {
          primary: "#ff0080",
          secondary: "#00ffff",
          accent: "#ffff00",
          background: "#1a1a1a",
          text: "#ffffff"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["neon-glow", "asymmetric", "bold-contrast"]
      },
      {
        id: "elegant-vintage",
        name: "\u4F18\u96C5\u590D\u53E4\u98CE\u683C",
        description: "\u91CD\u73B020\u4E16\u7EAA\u521D\u671F\u5370\u5237\u54C1\u7684\u7CBE\u81F4\u7F8E\u5B66",
        colors: {
          primary: "#8b4513",
          secondary: "#daa520",
          accent: "#f5f5dc",
          background: "#faf0e6",
          text: "#2f1b14"
        },
        fonts: {
          heading: "'Noto Serif SC', serif",
          body: "'Noto Serif SC', serif"
        },
        effects: ["ornamental-borders", "vintage-texture", "aged-paper"]
      },
      {
        id: "futuristic-tech",
        name: "\u672A\u6765\u79D1\u6280\u98CE\u683C",
        description: "\u5448\u73B0\u9AD8\u5EA6\u53D1\u8FBE\u7684\u6570\u5B57\u754C\u9762\u7F8E\u5B66",
        colors: {
          primary: "#00ffff",
          secondary: "#8a2be2",
          accent: "#00ff41",
          background: "#0a0a23",
          text: "#e6e6e6"
        },
        fonts: {
          heading: "'Courier New', monospace",
          body: "'Courier New', monospace"
        },
        effects: ["holographic", "data-streams", "scan-lines"]
      },
      {
        id: "scandinavian",
        name: "\u65AF\u582A\u7684\u7EB3\u7EF4\u4E9A\u98CE\u683C",
        description: "\u4F53\u73B0\u5317\u6B27\u8BBE\u8BA1\u7684\u7B80\u7EA6\u4E0E\u529F\u80FD\u7F8E\u5B66",
        colors: {
          primary: "#4a90e2",
          secondary: "#f5f5f5",
          accent: "#ffc0cb",
          background: "#ffffff",
          text: "#2c2c2c"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["natural-textures", "clean-geometry", "soft-shadows"]
      },
      {
        id: "art-deco",
        name: "\u827A\u672F\u88C5\u9970\u98CE\u683C",
        description: "\u91CD\u73B01920-30\u5E74\u4EE3\u7684\u5962\u534E\u4E0E\u51E0\u4F55\u7F8E\u5B66",
        colors: {
          primary: "#d4af37",
          secondary: "#000000",
          accent: "#ffffff",
          background: "#1a1a1a",
          text: "#d4af37"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["geometric-patterns", "gold-foil", "symmetrical-design"]
      },
      {
        id: "japanese-minimalism",
        name: "\u65E5\u5F0F\u6781\u7B80\u98CE\u683C",
        description: "\u4F53\u73B0'\u4F98\u5BC2'\u7F8E\u5B66\u2014\u2014\u63A5\u53D7\u4E0D\u5B8C\u7F8E\u3001\u65E0\u5E38\u4E0E\u4E0D\u5B8C\u6574\u7684\u54F2\u5B66",
        colors: {
          primary: "#2c2c2c",
          secondary: "#8e8e8e",
          accent: "#f8f8f8",
          background: "#ffffff",
          text: "#333333"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["ink-wash", "zen-spacing", "natural-imperfections"]
      },
      {
        id: "postmodern-deconstruction",
        name: "\u540E\u73B0\u4EE3\u89E3\u6784\u98CE\u683C",
        description: "\u5F7B\u5E95\u6253\u7834\u4F20\u7EDF\u8BBE\u8BA1\u89C4\u5219\u548C\u7F51\u683C\u7CFB\u7EDF",
        colors: {
          primary: "#ff6b6b",
          secondary: "#4ecdc4",
          accent: "#45b7d1",
          background: "#f9f9f9",
          text: "#2c2c2c"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["broken-grid", "overlapping-elements", "chaotic-order"]
      },
      {
        id: "punk",
        name: "\u670B\u514B\u98CE\u683C",
        description: "\u4F53\u73B0DIY\u7CBE\u795E\u548C\u53CD\u53DB\u6587\u5316",
        colors: {
          primary: "#ff0000",
          secondary: "#000000",
          accent: "#ffffff",
          background: "#f5f5f5",
          text: "#000000"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["torn-edges", "safety-pins", "spray-paint"]
      },
      {
        id: "british-rock",
        name: "\u82F1\u4F26\u6447\u6EDA\u98CE\u683C",
        description: "\u878D\u5408\u82F1\u56FD\u4F20\u7EDF\u5143\u7D20\u4E0E\u53CD\u53DB\u6447\u6EDA\u7F8E\u5B66",
        colors: {
          primary: "#dc143c",
          secondary: "#ffffff",
          accent: "#000080",
          background: "#f8f8ff",
          text: "#2c2c2c"
        },
        fonts: {
          heading: "'Noto Serif SC', serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["union-jack-elements", "vintage-records", "rock-textures"]
      },
      {
        id: "black-metal",
        name: "\u9ED1\u91D1\u5C5E\u98CE\u683C",
        description: "\u4F53\u73B0\u6781\u81F4\u9ED1\u6697\u7F8E\u5B66\u548C\u795E\u79D8\u4E3B\u4E49",
        colors: {
          primary: "#ffffff",
          secondary: "#666666",
          accent: "#ff0000",
          background: "#000000",
          text: "#ffffff"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["mystical-symbols", "gothic-elements", "dark-atmosphere"]
      },
      {
        id: "memphis-design",
        name: "\u5B5F\u83F2\u65AF\u98CE\u683C",
        description: "\u91CD\u73B080\u5E74\u4EE3\u610F\u5927\u5229\u8BBE\u8BA1\u8FD0\u52A8\u7684\u524D\u536B\u7F8E\u5B66",
        colors: {
          primary: "#ff69b4",
          secondary: "#00ffff",
          accent: "#ffff00",
          background: "#ffffff",
          text: "#333333"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["geometric-chaos", "neon-colors", "80s-vibes"]
      },
      {
        id: "cyberpunk",
        name: "\u8D5B\u535A\u670B\u514B\u98CE\u683C",
        description: "\u4F53\u73B0'\u9AD8\u79D1\u6280\uFF0C\u4F4E\u751F\u6D3B'\u7684\u53CD\u4E4C\u6258\u90A6\u7F8E\u5B66",
        colors: {
          primary: "#00ffff",
          secondary: "#ff00ff",
          accent: "#00ff00",
          background: "#0a0a0a",
          text: "#e6e6e6"
        },
        fonts: {
          heading: "'Courier New', monospace",
          body: "'Courier New', monospace"
        },
        effects: ["glitch-effects", "neon-lights", "digital-decay"]
      },
      {
        id: "pop-art",
        name: "\u6CE2\u666E\u827A\u672F\u98CE\u683C",
        description: "\u91CD\u73B060\u5E74\u4EE3\u827A\u672F\u8FD0\u52A8\u7684\u5927\u80C6\u7F8E\u5B66",
        colors: {
          primary: "#ff0000",
          secondary: "#ffff00",
          accent: "#0000ff",
          background: "#ffffff",
          text: "#000000"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["halftone-dots", "comic-elements", "bright-colors"]
      },
      {
        id: "deconstructed-swiss",
        name: "\u745E\u58EB\u56FD\u9645\u4E3B\u4E49\u98CE\u683C\u7684\u89E3\u6784\u7248",
        description: "\u5728\u4E25\u683C\u7F51\u683C\u7CFB\u7EDF\u7684\u57FA\u7840\u4E0A\u8FDB\u884C\u6709\u610F\u8BC6\u7684\u7834\u574F\u548C\u91CD\u7EC4",
        colors: {
          primary: "#ff0000",
          secondary: "#000000",
          accent: "#ffffff",
          background: "#f8f8f8",
          text: "#333333"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["broken-grid", "systematic-chaos", "helvetica-worship"]
      },
      {
        id: "vaporwave",
        name: "\u84B8\u6C7D\u6CE2\u7F8E\u5B66",
        description: "\u4F53\u73B0\u4E92\u8054\u7F51\u4E9A\u6587\u5316\u7684\u6000\u65E7\u672A\u6765\u4E3B\u4E49",
        colors: {
          primary: "#ff00ff",
          secondary: "#00ffff",
          accent: "#ffff00",
          background: "linear-gradient(135deg, #ff00ff, #00ffff)",
          text: "#ffffff"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["retro-gradients", "vhs-aesthetics", "90s-nostalgia"]
      },
      {
        id: "neo-expressionism",
        name: "\u65B0\u8868\u73B0\u4E3B\u4E49\u98CE\u683C",
        description: "\u4F53\u73B080\u5E74\u4EE3\u827A\u672F\u8FD0\u52A8\u7684\u539F\u59CB\u80FD\u91CF\u548C\u60C5\u611F\u8868\u8FBE",
        colors: {
          primary: "#ff4500",
          secondary: "#800080",
          accent: "#ffff00",
          background: "#2f2f2f",
          text: "#ffffff"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["brush-strokes", "emotional-chaos", "raw-energy"]
      },
      {
        id: "extreme-minimalism",
        name: "\u6781\u7B80\u4E3B\u4E49\u7684\u6781\u7AEF\u7248\u672C",
        description: "\u5C06'\u5C11\u5373\u662F\u591A'\u7684\u7406\u5FF5\u63A8\u5411\u6781\u81F4",
        colors: {
          primary: "#000000",
          secondary: "#999999",
          accent: "#f0f0f0",
          background: "#ffffff",
          text: "#333333"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["ultra-clean", "pixel-perfect", "zen-emptiness"]
      },
      {
        id: "neo-futurism",
        name: "\u65B0\u672A\u6765\u4E3B\u4E49",
        description: "\u4F53\u73B0\u5F53\u4EE3\u5EFA\u7B51\u548C\u4EA7\u54C1\u8BBE\u8BA1\u4E2D\u7684\u524D\u6CBF\u7F8E\u5B66",
        colors: {
          primary: "#c0c0c0",
          secondary: "#4169e1",
          accent: "#ffd700",
          background: "#f8f8ff",
          text: "#2c2c2c"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["fluid-forms", "metallic-textures", "parametric-design"]
      },
      {
        id: "surrealist-collage",
        name: "\u8D85\u73B0\u5B9E\u4E3B\u4E49\u6570\u5B57\u62FC\u8D34",
        description: "\u521B\u9020\u68A6\u5883\u822C\u7684\u89C6\u89C9\u53D9\u4E8B",
        colors: {
          primary: "#ff69b4",
          secondary: "#9370db",
          accent: "#ffd700",
          background: "linear-gradient(45deg, #ff69b4, #9370db)",
          text: "#ffffff"
        },
        fonts: {
          heading: "'Noto Serif SC', serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["dreamlike-elements", "impossible-geometry", "surreal-combinations"]
      },
      {
        id: "neo-baroque",
        name: "\u65B0\u5DF4\u6D1B\u514B\u6570\u5B57\u98CE\u683C",
        description: "\u5C0617\u4E16\u7EAA\u7684\u534E\u4E3D\u7F8E\u5B66\u91CD\u65B0\u8BE0\u91CA\u4E3A\u6570\u5B57\u5F62\u5F0F",
        colors: {
          primary: "#d4af37",
          secondary: "#8b0000",
          accent: "#4169e1",
          background: "#000000",
          text: "#ffd700"
        },
        fonts: {
          heading: "'Noto Serif SC', serif",
          body: "'Noto Serif SC', serif"
        },
        effects: ["ornate-decorations", "dramatic-lighting", "digital-baroque"]
      },
      {
        id: "liquid-morphism",
        name: "\u6DB2\u6001\u6570\u5B57\u5F62\u6001\u4E3B\u4E49",
        description: "\u7ED3\u5408\u6D41\u4F53\u52A8\u529B\u5B66\u4E0E\u6570\u5B57\u827A\u672F\u521B\u9020\u8D85\u524D\u536B\u89C6\u89C9\u4F53\u9A8C",
        colors: {
          primary: "#8a2be2",
          secondary: "#00bfff",
          accent: "#ff1493",
          background: "linear-gradient(135deg, #8a2be2, #00bfff)",
          text: "#ffffff"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["fluid-motion", "liquid-gradients", "morphing-shapes"]
      },
      {
        id: "hypersensory-minimalism",
        name: "\u8D85\u611F\u5B98\u6781\u7B80\u4E3B\u4E49",
        description: "\u5C06\u6781\u7B80\u7F8E\u5B66\u63A8\u5411\u611F\u5B98\u6781\u9650",
        colors: {
          primary: "#f8f8f8",
          secondary: "#e8e8e8",
          accent: "#d8d8d8",
          background: "#ffffff",
          text: "#333333"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["micro-interactions", "subtle-textures", "sensory-depth"]
      },
      {
        id: "neo-expressionist-data",
        name: "\u65B0\u8868\u73B0\u4E3B\u4E49\u6570\u636E\u53EF\u89C6\u5316",
        description: "\u5C06\u62BD\u8C61\u8868\u73B0\u4E3B\u4E49\u827A\u672F\u4E0E\u6570\u636E\u53EF\u89C6\u5316\u5B8C\u7F8E\u878D\u5408",
        colors: {
          primary: "#ff4500",
          secondary: "#4169e1",
          accent: "#ffd700",
          background: "#f8f8ff",
          text: "#2c2c2c"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["data-brushstrokes", "abstract-charts", "emotional-data"]
      },
      {
        id: "victorian",
        name: "\u7EF4\u591A\u5229\u4E9A\u98CE\u683C",
        description: "\u91CD\u73B019\u4E16\u7EAA\u82F1\u56FD\u7EF4\u591A\u5229\u4E9A\u65F6\u671F\u7684\u534E\u4E3D\u5370\u5237\u7F8E\u5B66",
        colors: {
          primary: "#8b4513",
          secondary: "#daa520",
          accent: "#dc143c",
          background: "#faf0e6",
          text: "#2f1b14"
        },
        fonts: {
          heading: "'Noto Serif SC', serif",
          body: "'Noto Serif SC', serif"
        },
        effects: ["ornate-borders", "vintage-typography", "period-decorations"]
      },
      {
        id: "bauhaus",
        name: "\u5305\u8C6A\u65AF\u98CE\u683C",
        description: "\u4F53\u73B020\u4E16\u7EAA\u65E9\u671F\u5FB7\u56FD\u5305\u8C6A\u65AF\u5B66\u6821\u7684\u529F\u80FD\u4E3B\u4E49\u7F8E\u5B66",
        colors: {
          primary: "#ff0000",
          secondary: "#ffff00",
          accent: "#0000ff",
          background: "#ffffff",
          text: "#000000"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["geometric-purity", "functional-design", "primary-colors"]
      },
      {
        id: "constructivism",
        name: "\u6784\u6210\u4E3B\u4E49\u98CE\u683C",
        description: "\u4F53\u73B020\u4E16\u7EAA\u65E9\u671F\u4FC4\u56FD\u524D\u536B\u827A\u672F\u8FD0\u52A8\u7684\u9769\u547D\u6027\u7F8E\u5B66",
        colors: {
          primary: "#ff0000",
          secondary: "#000000",
          accent: "#ffffff",
          background: "#f8f8f8",
          text: "#000000"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["diagonal-compositions", "revolutionary-graphics", "dynamic-tension"]
      },
      {
        id: "german-expressionism",
        name: "\u5FB7\u56FD\u8868\u73B0\u4E3B\u4E49\u98CE\u683C",
        description: "\u4F53\u73B020\u4E16\u7EAA\u521D\u671F\u5FB7\u56FD\u8868\u73B0\u4E3B\u4E49\u8FD0\u52A8\u7684\u5F3A\u70C8\u60C5\u611F\u8868\u8FBE",
        colors: {
          primary: "#ffff00",
          secondary: "#8b0000",
          accent: "#228b22",
          background: "#191970",
          text: "#ffffff"
        },
        fonts: {
          heading: "'Noto Sans SC', sans-serif",
          body: "'Noto Sans SC', sans-serif"
        },
        effects: ["dramatic-shadows", "emotional-distortion", "woodcut-aesthetic"]
      }
    ];
  }
});

// node_modules/html-to-image/es/util.js
function resolveUrl(url, baseUrl) {
  if (url.match(/^[a-z]+:\/\//i)) {
    return url;
  }
  if (url.match(/^\/\//)) {
    return window.location.protocol + url;
  }
  if (url.match(/^[a-z]+:/i)) {
    return url;
  }
  const doc = document.implementation.createHTMLDocument();
  const base = doc.createElement("base");
  const a = doc.createElement("a");
  doc.head.appendChild(base);
  doc.body.appendChild(a);
  if (baseUrl) {
    base.href = baseUrl;
  }
  a.href = url;
  return a.href;
}
function toArray(arrayLike) {
  const arr = [];
  for (let i = 0, l = arrayLike.length; i < l; i++) {
    arr.push(arrayLike[i]);
  }
  return arr;
}
function getStyleProperties(options = {}) {
  if (styleProps) {
    return styleProps;
  }
  if (options.includeStyleProperties) {
    styleProps = options.includeStyleProperties;
    return styleProps;
  }
  styleProps = toArray(window.getComputedStyle(document.documentElement));
  return styleProps;
}
function px(node, styleProperty) {
  const win = node.ownerDocument.defaultView || window;
  const val = win.getComputedStyle(node).getPropertyValue(styleProperty);
  return val ? parseFloat(val.replace("px", "")) : 0;
}
function getNodeWidth(node) {
  const leftBorder = px(node, "border-left-width");
  const rightBorder = px(node, "border-right-width");
  return node.clientWidth + leftBorder + rightBorder;
}
function getNodeHeight(node) {
  const topBorder = px(node, "border-top-width");
  const bottomBorder = px(node, "border-bottom-width");
  return node.clientHeight + topBorder + bottomBorder;
}
function getImageSize(targetNode, options = {}) {
  const width = options.width || getNodeWidth(targetNode);
  const height = options.height || getNodeHeight(targetNode);
  return { width, height };
}
function getPixelRatio() {
  let ratio;
  let FINAL_PROCESS;
  try {
    FINAL_PROCESS = process;
  } catch (e) {
  }
  const val = FINAL_PROCESS && FINAL_PROCESS.env ? FINAL_PROCESS.env.devicePixelRatio : null;
  if (val) {
    ratio = parseInt(val, 10);
    if (Number.isNaN(ratio)) {
      ratio = 1;
    }
  }
  return ratio || window.devicePixelRatio || 1;
}
function checkCanvasDimensions(canvas) {
  if (canvas.width > canvasDimensionLimit || canvas.height > canvasDimensionLimit) {
    if (canvas.width > canvasDimensionLimit && canvas.height > canvasDimensionLimit) {
      if (canvas.width > canvas.height) {
        canvas.height *= canvasDimensionLimit / canvas.width;
        canvas.width = canvasDimensionLimit;
      } else {
        canvas.width *= canvasDimensionLimit / canvas.height;
        canvas.height = canvasDimensionLimit;
      }
    } else if (canvas.width > canvasDimensionLimit) {
      canvas.height *= canvasDimensionLimit / canvas.width;
      canvas.width = canvasDimensionLimit;
    } else {
      canvas.width *= canvasDimensionLimit / canvas.height;
      canvas.height = canvasDimensionLimit;
    }
  }
}
function canvasToBlob(canvas, options = {}) {
  if (canvas.toBlob) {
    return new Promise((resolve) => {
      canvas.toBlob(resolve, options.type ? options.type : "image/png", options.quality ? options.quality : 1);
    });
  }
  return new Promise((resolve) => {
    const binaryString = window.atob(canvas.toDataURL(options.type ? options.type : void 0, options.quality ? options.quality : void 0).split(",")[1]);
    const len = binaryString.length;
    const binaryArray = new Uint8Array(len);
    for (let i = 0; i < len; i += 1) {
      binaryArray[i] = binaryString.charCodeAt(i);
    }
    resolve(new Blob([binaryArray], {
      type: options.type ? options.type : "image/png"
    }));
  });
}
function createImage(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      img.decode().then(() => {
        requestAnimationFrame(() => resolve(img));
      });
    };
    img.onerror = reject;
    img.crossOrigin = "anonymous";
    img.decoding = "async";
    img.src = url;
  });
}
async function svgToDataURL(svg) {
  return Promise.resolve().then(() => new XMLSerializer().serializeToString(svg)).then(encodeURIComponent).then((html) => `data:image/svg+xml;charset=utf-8,${html}`);
}
async function nodeToDataURL(node, width, height) {
  const xmlns = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(xmlns, "svg");
  const foreignObject = document.createElementNS(xmlns, "foreignObject");
  svg.setAttribute("width", `${width}`);
  svg.setAttribute("height", `${height}`);
  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
  foreignObject.setAttribute("width", "100%");
  foreignObject.setAttribute("height", "100%");
  foreignObject.setAttribute("x", "0");
  foreignObject.setAttribute("y", "0");
  foreignObject.setAttribute("externalResourcesRequired", "true");
  svg.appendChild(foreignObject);
  foreignObject.appendChild(node);
  return svgToDataURL(svg);
}
var uuid, styleProps, canvasDimensionLimit, isInstanceOfElement;
var init_util = __esm({
  "node_modules/html-to-image/es/util.js"() {
    uuid = (() => {
      let counter = 0;
      const random = () => (
        // eslint-disable-next-line no-bitwise
        `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
      );
      return () => {
        counter += 1;
        return `u${random()}${counter}`;
      };
    })();
    styleProps = null;
    canvasDimensionLimit = 16384;
    isInstanceOfElement = (node, instance) => {
      if (node instanceof instance)
        return true;
      const nodePrototype = Object.getPrototypeOf(node);
      if (nodePrototype === null)
        return false;
      return nodePrototype.constructor.name === instance.name || isInstanceOfElement(nodePrototype, instance);
    };
  }
});

// node_modules/html-to-image/es/clone-pseudos.js
function formatCSSText(style) {
  const content = style.getPropertyValue("content");
  return `${style.cssText} content: '${content.replace(/'|"/g, "")}';`;
}
function formatCSSProperties(style, options) {
  return getStyleProperties(options).map((name) => {
    const value = style.getPropertyValue(name);
    const priority = style.getPropertyPriority(name);
    return `${name}: ${value}${priority ? " !important" : ""};`;
  }).join(" ");
}
function getPseudoElementStyle(className, pseudo, style, options) {
  const selector = `.${className}:${pseudo}`;
  const cssText = style.cssText ? formatCSSText(style) : formatCSSProperties(style, options);
  return document.createTextNode(`${selector}{${cssText}}`);
}
function clonePseudoElement(nativeNode, clonedNode, pseudo, options) {
  const style = window.getComputedStyle(nativeNode, pseudo);
  const content = style.getPropertyValue("content");
  if (content === "" || content === "none") {
    return;
  }
  const className = uuid();
  try {
    clonedNode.className = `${clonedNode.className} ${className}`;
  } catch (err) {
    return;
  }
  const styleElement = document.createElement("style");
  styleElement.appendChild(getPseudoElementStyle(className, pseudo, style, options));
  clonedNode.appendChild(styleElement);
}
function clonePseudoElements(nativeNode, clonedNode, options) {
  clonePseudoElement(nativeNode, clonedNode, ":before", options);
  clonePseudoElement(nativeNode, clonedNode, ":after", options);
}
var init_clone_pseudos = __esm({
  "node_modules/html-to-image/es/clone-pseudos.js"() {
    init_util();
  }
});

// node_modules/html-to-image/es/mimes.js
function getExtension(url) {
  const match = /\.([^./]*?)$/g.exec(url);
  return match ? match[1] : "";
}
function getMimeType(url) {
  const extension = getExtension(url).toLowerCase();
  return mimes[extension] || "";
}
var WOFF, JPEG, mimes;
var init_mimes = __esm({
  "node_modules/html-to-image/es/mimes.js"() {
    WOFF = "application/font-woff";
    JPEG = "image/jpeg";
    mimes = {
      woff: WOFF,
      woff2: WOFF,
      ttf: "application/font-truetype",
      eot: "application/vnd.ms-fontobject",
      png: "image/png",
      jpg: JPEG,
      jpeg: JPEG,
      gif: "image/gif",
      tiff: "image/tiff",
      svg: "image/svg+xml",
      webp: "image/webp"
    };
  }
});

// node_modules/html-to-image/es/dataurl.js
function getContentFromDataUrl(dataURL) {
  return dataURL.split(/,/)[1];
}
function isDataUrl(url) {
  return url.search(/^(data:)/) !== -1;
}
function makeDataUrl(content, mimeType) {
  return `data:${mimeType};base64,${content}`;
}
async function fetchAsDataURL(url, init, process2) {
  const res = await fetch(url, init);
  if (res.status === 404) {
    throw new Error(`Resource "${res.url}" not found`);
  }
  const blob = await res.blob();
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = reject;
    reader.onloadend = () => {
      try {
        resolve(process2({ res, result: reader.result }));
      } catch (error) {
        reject(error);
      }
    };
    reader.readAsDataURL(blob);
  });
}
function getCacheKey(url, contentType, includeQueryParams) {
  let key = url.replace(/\?.*/, "");
  if (includeQueryParams) {
    key = url;
  }
  if (/ttf|otf|eot|woff2?/i.test(key)) {
    key = key.replace(/.*\//, "");
  }
  return contentType ? `[${contentType}]${key}` : key;
}
async function resourceToDataURL(resourceUrl, contentType, options) {
  const cacheKey = getCacheKey(resourceUrl, contentType, options.includeQueryParams);
  if (cache[cacheKey] != null) {
    return cache[cacheKey];
  }
  if (options.cacheBust) {
    resourceUrl += (/\?/.test(resourceUrl) ? "&" : "?") + new Date().getTime();
  }
  let dataURL;
  try {
    const content = await fetchAsDataURL(resourceUrl, options.fetchRequestInit, ({ res, result }) => {
      if (!contentType) {
        contentType = res.headers.get("Content-Type") || "";
      }
      return getContentFromDataUrl(result);
    });
    dataURL = makeDataUrl(content, contentType);
  } catch (error) {
    dataURL = options.imagePlaceholder || "";
    let msg = `Failed to fetch resource: ${resourceUrl}`;
    if (error) {
      msg = typeof error === "string" ? error : error.message;
    }
    if (msg) {
      console.warn(msg);
    }
  }
  cache[cacheKey] = dataURL;
  return dataURL;
}
var cache;
var init_dataurl = __esm({
  "node_modules/html-to-image/es/dataurl.js"() {
    cache = {};
  }
});

// node_modules/html-to-image/es/clone-node.js
async function cloneCanvasElement(canvas) {
  const dataURL = canvas.toDataURL();
  if (dataURL === "data:,") {
    return canvas.cloneNode(false);
  }
  return createImage(dataURL);
}
async function cloneVideoElement(video, options) {
  if (video.currentSrc) {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = video.clientWidth;
    canvas.height = video.clientHeight;
    ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const dataURL2 = canvas.toDataURL();
    return createImage(dataURL2);
  }
  const poster = video.poster;
  const contentType = getMimeType(poster);
  const dataURL = await resourceToDataURL(poster, contentType, options);
  return createImage(dataURL);
}
async function cloneIFrameElement(iframe, options) {
  var _a;
  try {
    if ((_a = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.body) {
      return await cloneNode(iframe.contentDocument.body, options, true);
    }
  } catch (_b) {
  }
  return iframe.cloneNode(false);
}
async function cloneSingleNode(node, options) {
  if (isInstanceOfElement(node, HTMLCanvasElement)) {
    return cloneCanvasElement(node);
  }
  if (isInstanceOfElement(node, HTMLVideoElement)) {
    return cloneVideoElement(node, options);
  }
  if (isInstanceOfElement(node, HTMLIFrameElement)) {
    return cloneIFrameElement(node, options);
  }
  return node.cloneNode(isSVGElement(node));
}
async function cloneChildren(nativeNode, clonedNode, options) {
  var _a, _b;
  if (isSVGElement(clonedNode)) {
    return clonedNode;
  }
  let children = [];
  if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {
    children = toArray(nativeNode.assignedNodes());
  } else if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && ((_a = nativeNode.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {
    children = toArray(nativeNode.contentDocument.body.childNodes);
  } else {
    children = toArray(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes);
  }
  if (children.length === 0 || isInstanceOfElement(nativeNode, HTMLVideoElement)) {
    return clonedNode;
  }
  await children.reduce((deferred, child) => deferred.then(() => cloneNode(child, options)).then((clonedChild) => {
    if (clonedChild) {
      clonedNode.appendChild(clonedChild);
    }
  }), Promise.resolve());
  return clonedNode;
}
function cloneCSSStyle(nativeNode, clonedNode, options) {
  const targetStyle = clonedNode.style;
  if (!targetStyle) {
    return;
  }
  const sourceStyle = window.getComputedStyle(nativeNode);
  if (sourceStyle.cssText) {
    targetStyle.cssText = sourceStyle.cssText;
    targetStyle.transformOrigin = sourceStyle.transformOrigin;
  } else {
    getStyleProperties(options).forEach((name) => {
      let value = sourceStyle.getPropertyValue(name);
      if (name === "font-size" && value.endsWith("px")) {
        const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;
        value = `${reducedFont}px`;
      }
      if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && name === "display" && value === "inline") {
        value = "block";
      }
      if (name === "d" && clonedNode.getAttribute("d")) {
        value = `path(${clonedNode.getAttribute("d")})`;
      }
      targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));
    });
  }
}
function cloneInputValue(nativeNode, clonedNode) {
  if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {
    clonedNode.innerHTML = nativeNode.value;
  }
  if (isInstanceOfElement(nativeNode, HTMLInputElement)) {
    clonedNode.setAttribute("value", nativeNode.value);
  }
}
function cloneSelectValue(nativeNode, clonedNode) {
  if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {
    const clonedSelect = clonedNode;
    const selectedOption = Array.from(clonedSelect.children).find((child) => nativeNode.value === child.getAttribute("value"));
    if (selectedOption) {
      selectedOption.setAttribute("selected", "");
    }
  }
}
function decorate(nativeNode, clonedNode, options) {
  if (isInstanceOfElement(clonedNode, Element)) {
    cloneCSSStyle(nativeNode, clonedNode, options);
    clonePseudoElements(nativeNode, clonedNode, options);
    cloneInputValue(nativeNode, clonedNode);
    cloneSelectValue(nativeNode, clonedNode);
  }
  return clonedNode;
}
async function ensureSVGSymbols(clone, options) {
  const uses = clone.querySelectorAll ? clone.querySelectorAll("use") : [];
  if (uses.length === 0) {
    return clone;
  }
  const processedDefs = {};
  for (let i = 0; i < uses.length; i++) {
    const use = uses[i];
    const id = use.getAttribute("xlink:href");
    if (id) {
      const exist = clone.querySelector(id);
      const definition = document.querySelector(id);
      if (!exist && definition && !processedDefs[id]) {
        processedDefs[id] = await cloneNode(definition, options, true);
      }
    }
  }
  const nodes = Object.values(processedDefs);
  if (nodes.length) {
    const ns = "http://www.w3.org/1999/xhtml";
    const svg = document.createElementNS(ns, "svg");
    svg.setAttribute("xmlns", ns);
    svg.style.position = "absolute";
    svg.style.width = "0";
    svg.style.height = "0";
    svg.style.overflow = "hidden";
    svg.style.display = "none";
    const defs = document.createElementNS(ns, "defs");
    svg.appendChild(defs);
    for (let i = 0; i < nodes.length; i++) {
      defs.appendChild(nodes[i]);
    }
    clone.appendChild(svg);
  }
  return clone;
}
async function cloneNode(node, options, isRoot) {
  if (!isRoot && options.filter && !options.filter(node)) {
    return null;
  }
  return Promise.resolve(node).then((clonedNode) => cloneSingleNode(clonedNode, options)).then((clonedNode) => cloneChildren(node, clonedNode, options)).then((clonedNode) => decorate(node, clonedNode, options)).then((clonedNode) => ensureSVGSymbols(clonedNode, options));
}
var isSlotElement, isSVGElement;
var init_clone_node = __esm({
  "node_modules/html-to-image/es/clone-node.js"() {
    init_clone_pseudos();
    init_util();
    init_mimes();
    init_dataurl();
    isSlotElement = (node) => node.tagName != null && node.tagName.toUpperCase() === "SLOT";
    isSVGElement = (node) => node.tagName != null && node.tagName.toUpperCase() === "SVG";
  }
});

// node_modules/html-to-image/es/embed-resources.js
function toRegex(url) {
  const escaped = url.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
  return new RegExp(`(url\\(['"]?)(${escaped})(['"]?\\))`, "g");
}
function parseURLs(cssText) {
  const urls = [];
  cssText.replace(URL_REGEX, (raw, quotation, url) => {
    urls.push(url);
    return raw;
  });
  return urls.filter((url) => !isDataUrl(url));
}
async function embed(cssText, resourceURL, baseURL, options, getContentFromUrl) {
  try {
    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;
    const contentType = getMimeType(resourceURL);
    let dataURL;
    if (getContentFromUrl) {
      const content = await getContentFromUrl(resolvedURL);
      dataURL = makeDataUrl(content, contentType);
    } else {
      dataURL = await resourceToDataURL(resolvedURL, contentType, options);
    }
    return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`);
  } catch (error) {
  }
  return cssText;
}
function filterPreferredFontFormat(str, { preferredFontFormat }) {
  return !preferredFontFormat ? str : str.replace(FONT_SRC_REGEX, (match) => {
    while (true) {
      const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];
      if (!format) {
        return "";
      }
      if (format === preferredFontFormat) {
        return `src: ${src};`;
      }
    }
  });
}
function shouldEmbed(url) {
  return url.search(URL_REGEX) !== -1;
}
async function embedResources(cssText, baseUrl, options) {
  if (!shouldEmbed(cssText)) {
    return cssText;
  }
  const filteredCSSText = filterPreferredFontFormat(cssText, options);
  const urls = parseURLs(filteredCSSText);
  return urls.reduce((deferred, url) => deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText));
}
var URL_REGEX, URL_WITH_FORMAT_REGEX, FONT_SRC_REGEX;
var init_embed_resources = __esm({
  "node_modules/html-to-image/es/embed-resources.js"() {
    init_util();
    init_mimes();
    init_dataurl();
    URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g;
    URL_WITH_FORMAT_REGEX = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g;
    FONT_SRC_REGEX = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
  }
});

// node_modules/html-to-image/es/embed-images.js
async function embedProp(propName, node, options) {
  var _a;
  const propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);
  if (propValue) {
    const cssString = await embedResources(propValue, null, options);
    node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));
    return true;
  }
  return false;
}
async function embedBackground(clonedNode, options) {
  ;
  await embedProp("background", clonedNode, options) || await embedProp("background-image", clonedNode, options);
  await embedProp("mask", clonedNode, options) || await embedProp("-webkit-mask", clonedNode, options) || await embedProp("mask-image", clonedNode, options) || await embedProp("-webkit-mask-image", clonedNode, options);
}
async function embedImageNode(clonedNode, options) {
  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);
  if (!(isImageElement && !isDataUrl(clonedNode.src)) && !(isInstanceOfElement(clonedNode, SVGImageElement) && !isDataUrl(clonedNode.href.baseVal))) {
    return;
  }
  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;
  const dataURL = await resourceToDataURL(url, getMimeType(url), options);
  await new Promise((resolve, reject) => {
    clonedNode.onload = resolve;
    clonedNode.onerror = options.onImageErrorHandler ? (...attributes) => {
      try {
        resolve(options.onImageErrorHandler(...attributes));
      } catch (error) {
        reject(error);
      }
    } : reject;
    const image = clonedNode;
    if (image.decode) {
      image.decode = resolve;
    }
    if (image.loading === "lazy") {
      image.loading = "eager";
    }
    if (isImageElement) {
      clonedNode.srcset = "";
      clonedNode.src = dataURL;
    } else {
      clonedNode.href.baseVal = dataURL;
    }
  });
}
async function embedChildren(clonedNode, options) {
  const children = toArray(clonedNode.childNodes);
  const deferreds = children.map((child) => embedImages(child, options));
  await Promise.all(deferreds).then(() => clonedNode);
}
async function embedImages(clonedNode, options) {
  if (isInstanceOfElement(clonedNode, Element)) {
    await embedBackground(clonedNode, options);
    await embedImageNode(clonedNode, options);
    await embedChildren(clonedNode, options);
  }
}
var init_embed_images = __esm({
  "node_modules/html-to-image/es/embed-images.js"() {
    init_embed_resources();
    init_util();
    init_dataurl();
    init_mimes();
  }
});

// node_modules/html-to-image/es/apply-style.js
function applyStyle(node, options) {
  const { style } = node;
  if (options.backgroundColor) {
    style.backgroundColor = options.backgroundColor;
  }
  if (options.width) {
    style.width = `${options.width}px`;
  }
  if (options.height) {
    style.height = `${options.height}px`;
  }
  const manual = options.style;
  if (manual != null) {
    Object.keys(manual).forEach((key) => {
      style[key] = manual[key];
    });
  }
  return node;
}
var init_apply_style = __esm({
  "node_modules/html-to-image/es/apply-style.js"() {
  }
});

// node_modules/html-to-image/es/embed-webfonts.js
async function fetchCSS(url) {
  let cache2 = cssFetchCache[url];
  if (cache2 != null) {
    return cache2;
  }
  const res = await fetch(url);
  const cssText = await res.text();
  cache2 = { url, cssText };
  cssFetchCache[url] = cache2;
  return cache2;
}
async function embedFonts(data, options) {
  let cssText = data.cssText;
  const regexUrl = /url\(["']?([^"')]+)["']?\)/g;
  const fontLocs = cssText.match(/url\([^)]+\)/g) || [];
  const loadFonts = fontLocs.map(async (loc) => {
    let url = loc.replace(regexUrl, "$1");
    if (!url.startsWith("https://")) {
      url = new URL(url, data.url).href;
    }
    return fetchAsDataURL(url, options.fetchRequestInit, ({ result }) => {
      cssText = cssText.replace(loc, `url(${result})`);
      return [loc, result];
    });
  });
  return Promise.all(loadFonts).then(() => cssText);
}
function parseCSS(source) {
  if (source == null) {
    return [];
  }
  const result = [];
  const commentsRegex = /(\/\*[\s\S]*?\*\/)/gi;
  let cssText = source.replace(commentsRegex, "");
  const keyframesRegex = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
  while (true) {
    const matches = keyframesRegex.exec(cssText);
    if (matches === null) {
      break;
    }
    result.push(matches[0]);
  }
  cssText = cssText.replace(keyframesRegex, "");
  const importRegex = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;
  const combinedCSSRegex = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})";
  const unifiedRegex = new RegExp(combinedCSSRegex, "gi");
  while (true) {
    let matches = importRegex.exec(cssText);
    if (matches === null) {
      matches = unifiedRegex.exec(cssText);
      if (matches === null) {
        break;
      } else {
        importRegex.lastIndex = unifiedRegex.lastIndex;
      }
    } else {
      unifiedRegex.lastIndex = importRegex.lastIndex;
    }
    result.push(matches[0]);
  }
  return result;
}
async function getCSSRules(styleSheets, options) {
  const ret = [];
  const deferreds = [];
  styleSheets.forEach((sheet) => {
    if ("cssRules" in sheet) {
      try {
        toArray(sheet.cssRules || []).forEach((item, index) => {
          if (item.type === CSSRule.IMPORT_RULE) {
            let importIndex = index + 1;
            const url = item.href;
            const deferred = fetchCSS(url).then((metadata) => embedFonts(metadata, options)).then((cssText) => parseCSS(cssText).forEach((rule) => {
              try {
                sheet.insertRule(rule, rule.startsWith("@import") ? importIndex += 1 : sheet.cssRules.length);
              } catch (error) {
                console.error("Error inserting rule from remote css", {
                  rule,
                  error
                });
              }
            })).catch((e) => {
              console.error("Error loading remote css", e.toString());
            });
            deferreds.push(deferred);
          }
        });
      } catch (e) {
        const inline = styleSheets.find((a) => a.href == null) || document.styleSheets[0];
        if (sheet.href != null) {
          deferreds.push(fetchCSS(sheet.href).then((metadata) => embedFonts(metadata, options)).then((cssText) => parseCSS(cssText).forEach((rule) => {
            inline.insertRule(rule, inline.cssRules.length);
          })).catch((err) => {
            console.error("Error loading remote stylesheet", err);
          }));
        }
        console.error("Error inlining remote css file", e);
      }
    }
  });
  return Promise.all(deferreds).then(() => {
    styleSheets.forEach((sheet) => {
      if ("cssRules" in sheet) {
        try {
          toArray(sheet.cssRules || []).forEach((item) => {
            ret.push(item);
          });
        } catch (e) {
          console.error(`Error while reading CSS rules from ${sheet.href}`, e);
        }
      }
    });
    return ret;
  });
}
function getWebFontRules(cssRules) {
  return cssRules.filter((rule) => rule.type === CSSRule.FONT_FACE_RULE).filter((rule) => shouldEmbed(rule.style.getPropertyValue("src")));
}
async function parseWebFontRules(node, options) {
  if (node.ownerDocument == null) {
    throw new Error("Provided element is not within a Document");
  }
  const styleSheets = toArray(node.ownerDocument.styleSheets);
  const cssRules = await getCSSRules(styleSheets, options);
  return getWebFontRules(cssRules);
}
function normalizeFontFamily(font) {
  return font.trim().replace(/["']/g, "");
}
function getUsedFonts(node) {
  const fonts = /* @__PURE__ */ new Set();
  function traverse(node2) {
    const fontFamily = node2.style.fontFamily || getComputedStyle(node2).fontFamily;
    fontFamily.split(",").forEach((font) => {
      fonts.add(normalizeFontFamily(font));
    });
    Array.from(node2.children).forEach((child) => {
      if (child instanceof HTMLElement) {
        traverse(child);
      }
    });
  }
  traverse(node);
  return fonts;
}
async function getWebFontCSS(node, options) {
  const rules = await parseWebFontRules(node, options);
  const usedFonts = getUsedFonts(node);
  const cssTexts = await Promise.all(rules.filter((rule) => usedFonts.has(normalizeFontFamily(rule.style.fontFamily))).map((rule) => {
    const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;
    return embedResources(rule.cssText, baseUrl, options);
  }));
  return cssTexts.join("\n");
}
async function embedWebFonts(clonedNode, options) {
  const cssText = options.fontEmbedCSS != null ? options.fontEmbedCSS : options.skipFonts ? null : await getWebFontCSS(clonedNode, options);
  if (cssText) {
    const styleNode = document.createElement("style");
    const sytleContent = document.createTextNode(cssText);
    styleNode.appendChild(sytleContent);
    if (clonedNode.firstChild) {
      clonedNode.insertBefore(styleNode, clonedNode.firstChild);
    } else {
      clonedNode.appendChild(styleNode);
    }
  }
}
var cssFetchCache;
var init_embed_webfonts = __esm({
  "node_modules/html-to-image/es/embed-webfonts.js"() {
    init_util();
    init_dataurl();
    init_embed_resources();
    cssFetchCache = {};
  }
});

// node_modules/html-to-image/es/index.js
var es_exports = {};
__export(es_exports, {
  getFontEmbedCSS: () => getFontEmbedCSS,
  toBlob: () => toBlob,
  toCanvas: () => toCanvas,
  toJpeg: () => toJpeg,
  toPixelData: () => toPixelData,
  toPng: () => toPng,
  toSvg: () => toSvg
});
async function toSvg(node, options = {}) {
  const { width, height } = getImageSize(node, options);
  const clonedNode = await cloneNode(node, options, true);
  await embedWebFonts(clonedNode, options);
  await embedImages(clonedNode, options);
  applyStyle(clonedNode, options);
  const datauri = await nodeToDataURL(clonedNode, width, height);
  return datauri;
}
async function toCanvas(node, options = {}) {
  const { width, height } = getImageSize(node, options);
  const svg = await toSvg(node, options);
  const img = await createImage(svg);
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  const ratio = options.pixelRatio || getPixelRatio();
  const canvasWidth = options.canvasWidth || width;
  const canvasHeight = options.canvasHeight || height;
  canvas.width = canvasWidth * ratio;
  canvas.height = canvasHeight * ratio;
  if (!options.skipAutoScale) {
    checkCanvasDimensions(canvas);
  }
  canvas.style.width = `${canvasWidth}`;
  canvas.style.height = `${canvasHeight}`;
  if (options.backgroundColor) {
    context.fillStyle = options.backgroundColor;
    context.fillRect(0, 0, canvas.width, canvas.height);
  }
  context.drawImage(img, 0, 0, canvas.width, canvas.height);
  return canvas;
}
async function toPixelData(node, options = {}) {
  const { width, height } = getImageSize(node, options);
  const canvas = await toCanvas(node, options);
  const ctx = canvas.getContext("2d");
  return ctx.getImageData(0, 0, width, height).data;
}
async function toPng(node, options = {}) {
  const canvas = await toCanvas(node, options);
  return canvas.toDataURL();
}
async function toJpeg(node, options = {}) {
  const canvas = await toCanvas(node, options);
  return canvas.toDataURL("image/jpeg", options.quality || 1);
}
async function toBlob(node, options = {}) {
  const canvas = await toCanvas(node, options);
  const blob = await canvasToBlob(canvas);
  return blob;
}
async function getFontEmbedCSS(node, options = {}) {
  return getWebFontCSS(node, options);
}
var init_es = __esm({
  "node_modules/html-to-image/es/index.js"() {
    init_clone_node();
    init_embed_images();
    init_apply_style();
    init_embed_webfonts();
    init_util();
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MicrofeedPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/settings.ts
var import_obsidian3 = require("obsidian");

// src/microfeedClient.ts
var import_obsidian = require("obsidian");
var MicrofeedClient = class {
  constructor(apiUrl, apiKey) {
    this.apiUrl = apiUrl.replace(/\/$/, "");
    this.apiKey = apiKey;
  }
  async createItem(item) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.apiUrl}/api/items/`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-MicrofeedAPI-Key": this.apiKey
      },
      body: JSON.stringify(item)
    });
    if (response.status < 200 || response.status >= 300) {
      throw new Error(`Failed to create item: ${response.status}. ${response.text}`);
    }
    return response.json;
  }
  async updateItem(itemId, item) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.apiUrl}/api/items/${itemId}/`,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        "X-MicrofeedAPI-Key": this.apiKey
      },
      body: JSON.stringify(item)
    });
    if (response.status < 200 || response.status >= 300) {
      throw new Error(`Failed to update item: ${response.status}. ${response.text}`);
    }
    return response.json;
  }
  async getPresignedUrl(category, filePath, itemId) {
    const payload = {
      category,
      full_local_file_path: filePath
    };
    if (itemId) {
      payload.item_id = itemId;
    }
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.apiUrl}/api/media_files/presigned_urls/`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-MicrofeedAPI-Key": this.apiKey
      },
      body: JSON.stringify(payload)
    });
    if (response.status < 200 || response.status >= 300) {
      throw new Error(`Failed to get presigned URL: ${response.status}. ${response.text}`);
    }
    return response.json;
  }
  async uploadFile(presignedUrl, file) {
    const arrayBuffer = await file.arrayBuffer();
    const response = await (0, import_obsidian.requestUrl)({
      url: presignedUrl,
      method: "PUT",
      body: arrayBuffer
    });
    if (response.status < 200 || response.status >= 300) {
      throw new Error(`Failed to upload file: ${response.status}`);
    }
  }
  async uploadMediaFile(file, category, fileName, itemId) {
    try {
      const presignedResponse = await this.getPresignedUrl(category, fileName, itemId);
      await this.uploadFile(presignedResponse.presigned_url, file);
      return presignedResponse.media_url;
    } catch (error) {
      console.error("Error uploading media file:", error);
      throw error;
    }
  }
  getMimeType(fileName, mediaType) {
    const extension = fileName.toLowerCase().split(".").pop() || "";
    const mimeTypes = {
      // Audio
      "mp3": "audio/mpeg",
      "wav": "audio/wav",
      "m4a": "audio/mp4",
      "aac": "audio/aac",
      "ogg": "audio/ogg",
      "flac": "audio/flac",
      // Video
      "mp4": "video/mp4",
      "mov": "video/quicktime",
      "avi": "video/x-msvideo",
      "mkv": "video/x-matroska",
      "webm": "video/webm",
      "m4v": "video/mp4",
      // Images
      "jpg": "image/jpeg",
      "jpeg": "image/jpeg",
      "png": "image/png",
      "gif": "image/gif",
      "webp": "image/webp",
      "svg": "image/svg+xml",
      // Documents
      "pdf": "application/pdf",
      "doc": "application/msword",
      "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "txt": "text/plain",
      "rtf": "application/rtf"
    };
    return mimeTypes[extension] || `${mediaType}/*`;
  }
  async getFileSize(file) {
    return file.size;
  }
  async getMediaDuration(file) {
    return new Promise((resolve) => {
      if (file.type.startsWith("audio/")) {
        const audio = new Audio();
        audio.onloadedmetadata = () => {
          resolve(Math.round(audio.duration));
        };
        audio.onerror = () => resolve(void 0);
        audio.src = URL.createObjectURL(file);
      } else if (file.type.startsWith("video/")) {
        const video = document.createElement("video");
        video.onloadedmetadata = () => {
          resolve(Math.round(video.duration));
          URL.revokeObjectURL(video.src);
        };
        video.onerror = () => {
          resolve(void 0);
          URL.revokeObjectURL(video.src);
        };
        video.src = URL.createObjectURL(file);
      } else {
        resolve(void 0);
      }
    });
  }
  async testConnection() {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.apiUrl}/api/feed/`,
        method: "GET",
        headers: {
          "X-MicrofeedAPI-Key": this.apiKey
        }
      });
      return response.status >= 200 && response.status < 300;
    } catch (error) {
      console.error("Connection test failed:", error);
      return false;
    }
  }
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  apiUrl: "https://your-microfeed-instance.com",
  apiKey: "",
  defaultStatus: "published",
  autoGenerateImage: true,
  imageTemplate: "detailed",
  twitter: {
    apiKey: "",
    apiSecret: "",
    accessToken: "",
    accessTokenSecret: "",
    bearerToken: "",
    enabled: false,
    autoPost: false,
    postFormat: "title_with_link",
    includeHashtags: false,
    customHashtags: "#microfeed"
  }
};
var MicrofeedSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Microfeed Publisher Settings" });
    new import_obsidian3.Setting(containerEl).setName("Microfeed API URL").setDesc("The base URL of your Microfeed instance").addText((text) => text.setPlaceholder("https://your-domain.com").setValue(this.plugin.settings.apiUrl).onChange(async (value) => {
      this.plugin.settings.apiUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("API Key").setDesc("Your Microfeed API key (get it from /admin/settings/)").addText((text) => {
      text.inputEl.type = "password";
      text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
        this.plugin.settings.apiKey = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Test Connection").setDesc("Test your API connection").addButton((button) => button.setButtonText("Test Connection").setCta().onClick(async () => {
      const { apiUrl, apiKey } = this.plugin.settings;
      if (!apiUrl || !apiKey) {
        this.showNotice("Please configure API URL and API Key first", "error");
        return;
      }
      button.setButtonText("Testing...");
      button.setDisabled(true);
      try {
        const client = new MicrofeedClient(apiUrl, apiKey);
        const isConnected = await client.testConnection();
        if (isConnected) {
          this.showNotice("\u2705 Connection successful!", "success");
        } else {
          this.showNotice("\u274C Connection failed. Check your settings.", "error");
        }
      } catch (error) {
        this.showNotice(`\u274C Connection error: ${error.message}`, "error");
      } finally {
        button.setButtonText("Test Connection");
        button.setDisabled(false);
      }
    }));
    new import_obsidian3.Setting(containerEl).setName("Default Publication Status").setDesc("Default status for published items").addDropdown((dropdown) => dropdown.addOption("published", "Published").addOption("unlisted", "Unlisted").addOption("unpublished", "Unpublished").setValue(this.plugin.settings.defaultStatus).onChange(async (value) => {
      this.plugin.settings.defaultStatus = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Image Generation" });
    new import_obsidian3.Setting(containerEl).setName("Auto-generate thumbnails").setDesc("Automatically generate thumbnail images for posts without images").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoGenerateImage).onChange(async (value) => {
      this.plugin.settings.autoGenerateImage = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Image Template").setDesc("Choose the style for auto-generated images").addDropdown((dropdown) => dropdown.addOption("simple", "Simple (title only)").addOption("detailed", "Detailed (title + content preview)").setValue(this.plugin.settings.imageTemplate).onChange(async (value) => {
      this.plugin.settings.imageTemplate = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Twitter/X Integration" });
    new import_obsidian3.Setting(containerEl).setName("Enable Twitter/X Integration").setDesc("Allow posting to Twitter/X when publishing content").addToggle((toggle) => toggle.setValue(this.plugin.settings.twitter.enabled).onChange(async (value) => {
      this.plugin.settings.twitter.enabled = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.twitter.enabled) {
      new import_obsidian3.Setting(containerEl).setName("Twitter API Key").setDesc("Your Twitter API Key (also called Consumer Key)").addText((text) => {
        text.inputEl.type = "password";
        text.setPlaceholder("Enter your API Key").setValue(this.plugin.settings.twitter.apiKey).onChange(async (value) => {
          this.plugin.settings.twitter.apiKey = value;
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian3.Setting(containerEl).setName("Twitter API Secret").setDesc("Your Twitter API Secret (also called Consumer Secret)").addText((text) => {
        text.inputEl.type = "password";
        text.setPlaceholder("Enter your API Secret").setValue(this.plugin.settings.twitter.apiSecret).onChange(async (value) => {
          this.plugin.settings.twitter.apiSecret = value;
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian3.Setting(containerEl).setName("Twitter Access Token").setDesc("Your Twitter Access Token").addText((text) => {
        text.inputEl.type = "password";
        text.setPlaceholder("Enter your Access Token").setValue(this.plugin.settings.twitter.accessToken).onChange(async (value) => {
          this.plugin.settings.twitter.accessToken = value;
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian3.Setting(containerEl).setName("Twitter Access Token Secret").setDesc("Your Twitter Access Token Secret").addText((text) => {
        text.inputEl.type = "password";
        text.setPlaceholder("Enter your Access Token Secret").setValue(this.plugin.settings.twitter.accessTokenSecret).onChange(async (value) => {
          this.plugin.settings.twitter.accessTokenSecret = value;
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian3.Setting(containerEl).setName("Twitter Bearer Token").setDesc("Your Twitter Bearer Token (for OAuth 2.0)").addText((text) => {
        text.inputEl.type = "password";
        text.setPlaceholder("Enter your Bearer Token").setValue(this.plugin.settings.twitter.bearerToken).onChange(async (value) => {
          this.plugin.settings.twitter.bearerToken = value;
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian3.Setting(containerEl).setName("Test Twitter Connection").setDesc("Test your Twitter API connection").addButton((button) => button.setButtonText("Test Connection").onClick(async () => {
        const { twitter } = this.plugin.settings;
        if (!twitter.apiKey || !twitter.apiSecret || !twitter.accessToken || !twitter.accessTokenSecret || !twitter.bearerToken) {
          this.showNotice("Please configure all Twitter API credentials first", "error");
          return;
        }
        button.setButtonText("Testing...");
        button.setDisabled(true);
        try {
          const { TwitterClient: TwitterClient2 } = await Promise.resolve().then(() => (init_twitterClient(), twitterClient_exports));
          const client = new TwitterClient2(twitter);
          const isConnected = await client.testConnection();
          if (isConnected) {
            this.showNotice("\u2705 Twitter connection successful!", "success");
          } else {
            this.showNotice("\u274C Twitter connection failed. Check your credentials.", "error");
          }
        } catch (error) {
          this.showNotice(`\u274C Twitter connection error: ${error.message}`, "error");
        } finally {
          button.setButtonText("Test Connection");
          button.setDisabled(false);
        }
      }));
      new import_obsidian3.Setting(containerEl).setName("Auto-post to Twitter/X").setDesc("Automatically post to Twitter when publishing to Microfeed").addToggle((toggle) => toggle.setValue(this.plugin.settings.twitter.autoPost).onChange(async (value) => {
        this.plugin.settings.twitter.autoPost = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian3.Setting(containerEl).setName("Twitter Post Format").setDesc("Choose how your content appears on Twitter").addDropdown((dropdown) => dropdown.addOption("title_only", "Title only").addOption("title_with_link", "Title + Microfeed link").addOption("title_with_summary", "Title + Summary + Link").setValue(this.plugin.settings.twitter.postFormat).onChange(async (value) => {
        this.plugin.settings.twitter.postFormat = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian3.Setting(containerEl).setName("Include Hashtags").setDesc("Include custom hashtags in Twitter posts").addToggle((toggle) => toggle.setValue(this.plugin.settings.twitter.includeHashtags).onChange(async (value) => {
        this.plugin.settings.twitter.includeHashtags = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian3.Setting(containerEl).setName("Custom Hashtags").setDesc("Comma-separated hashtags to include (e.g., #microfeed #blog)").addText((text) => text.setPlaceholder("#microfeed, #obsidian").setValue(this.plugin.settings.twitter.customHashtags).onChange(async (value) => {
        this.plugin.settings.twitter.customHashtags = value;
        await this.plugin.saveSettings();
      }));
    }
    containerEl.createEl("h3", { text: "Help" });
    const helpDiv = containerEl.createDiv();
    helpDiv.innerHTML = `
      <p><strong>How to use:</strong></p>
      <ol>
        <li>Configure your Microfeed API URL and API Key above</li>
        <li>Optional: Set up Twitter/X integration for automatic posting</li>
        <li>Open any markdown note in Obsidian</li>
        <li>Use the command palette (Cmd/Ctrl + P) and search for "Publish to Microfeed"</li>
        <li>The plugin will automatically parse your content and upload it</li>
      </ol>
      
      <p><strong>Supported media:</strong></p>
      <ul>
        <li>Audio: .mp3, .wav, .m4a, .aac, .ogg, .flac</li>
        <li>Video: .mp4, .mov, .avi, .mkv, .webm, .m4v</li>
        <li>Images: .jpg, .jpeg, .png, .gif, .webp, .svg</li>
        <li>Documents: .pdf, .doc, .docx, .txt, .rtf</li>
        <li>External URLs are also supported</li>
      </ul>
      
      <p><strong>Front matter support:</strong></p>
      <p>You can use YAML front matter to specify metadata:</p>
      <pre>---
title: My Post Title
status: published
itunes:explicit: false
itunes:season: 1
itunes:episode: 5
---</pre>
      
      <p><strong>Twitter/X Integration:</strong></p>
      <p>To set up Twitter/X posting:</p>
      <ol>
        <li>Go to <a href="https://developer.twitter.com">developer.twitter.com</a></li>
        <li>Create a new app and get your API credentials</li>
        <li>Enable OAuth 1.0a and OAuth 2.0 in your app settings</li>
        <li>Enter your credentials in the Twitter/X settings above</li>
        <li>Test the connection before enabling auto-posting</li>
      </ol>
    `;
  }
  showNotice(message, type) {
    const notice = this.app.workspace.containerEl.createDiv({
      cls: `notice ${type === "success" ? "notice-success" : "notice-error"}`
    });
    notice.textContent = message;
    setTimeout(() => {
      notice.remove();
    }, 5e3);
  }
};

// src/contentParser.ts
var ContentParser = class {
  static parseMarkdownContent(content, fileName) {
    const lines = content.split("\n");
    let frontMatterEnd = 0;
    let frontMatter = {};
    if (lines[0].trim() === "---") {
      for (let i = 1; i < lines.length; i++) {
        if (lines[i].trim() === "---") {
          frontMatterEnd = i + 1;
          break;
        }
      }
      if (frontMatterEnd > 0) {
        const frontMatterContent = lines.slice(1, frontMatterEnd - 1).join("\n");
        frontMatter = this.parseFrontMatter(frontMatterContent);
      }
    }
    const bodyContent = lines.slice(frontMatterEnd).join("\n");
    const title = frontMatter.title || this.extractTitleFromContent(bodyContent) || fileName.replace(/\.md$/, "");
    const mediaFiles = this.extractMediaFiles(bodyContent);
    const cleanContent = this.cleanContent(bodyContent, mediaFiles);
    return {
      title,
      content: cleanContent,
      mediaFiles,
      frontMatter
    };
  }
  static parseFrontMatter(content) {
    const frontMatter = {};
    const lines = content.split("\n");
    for (const line of lines) {
      const match = line.match(/^([^:]+):\\s*(.*)$/);
      if (match) {
        const [, key, value] = match;
        frontMatter[key.trim()] = this.parseYamlValue(value.trim());
      }
    }
    return frontMatter;
  }
  static parseYamlValue(value) {
    if (value === "true")
      return true;
    if (value === "false")
      return false;
    if (value.match(/^\d+$/))
      return parseInt(value);
    if (value.match(/^\d+\.\d+$/))
      return parseFloat(value);
    if (value.startsWith('"') && value.endsWith('"'))
      return value.slice(1, -1);
    if (value.startsWith("'") && value.endsWith("'"))
      return value.slice(1, -1);
    return value;
  }
  static extractTitleFromContent(content) {
    const match = content.match(/^#\\s+(.+)$/m);
    return match ? match[1].trim() : null;
  }
  static extractMediaFiles(content) {
    const mediaFiles = [];
    const linkRegex = /!?\[([^\]]*)\]\(([^)]+)\)/g;
    let match;
    while ((match = linkRegex.exec(content)) !== null) {
      const [fullMatch, alt, url] = match;
      const isImage = fullMatch.startsWith("!");
      if (this.isExternalUrl(url)) {
        mediaFiles.push({
          type: "external_url",
          url,
          title: alt || void 0
        });
      } else {
        const mediaType = this.getMediaType(url);
        if (mediaType) {
          mediaFiles.push({
            type: mediaType,
            url,
            title: alt || void 0
          });
        }
      }
    }
    const urlRegex = /https?:\/\/[^\s<>"{}|\\^`\[\]]+/g;
    while ((match = urlRegex.exec(content)) !== null) {
      const url = match[0];
      const mediaType = this.getMediaType(url);
      if (mediaType && !mediaFiles.some((f) => f.url === url)) {
        mediaFiles.push({
          type: mediaType,
          url
        });
      }
    }
    return mediaFiles;
  }
  static isExternalUrl(url) {
    return url.startsWith("http://") || url.startsWith("https://");
  }
  static getMediaType(url) {
    const lowerUrl = url.toLowerCase();
    for (const [type, extensions] of Object.entries(this.MEDIA_EXTENSIONS)) {
      if (extensions.some((ext) => lowerUrl.includes(ext))) {
        return type;
      }
    }
    return null;
  }
  static cleanContent(content, mediaFiles) {
    let cleanedContent = content;
    for (const mediaFile of mediaFiles) {
      if (mediaFile.type !== "external_url") {
        const escapedUrl = mediaFile.url.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        cleanedContent = cleanedContent.replace(
          new RegExp(`!?\\[([^\\]]*)\\]\\(${escapedUrl}\\)`, "g"),
          ""
        );
      }
    }
    return cleanedContent.trim();
  }
  static selectMainAttachment(mediaFiles) {
    const priorities = ["audio", "video", "image", "document", "external_url"];
    for (const priority of priorities) {
      const file = mediaFiles.find((f) => f.type === priority);
      if (file)
        return file;
    }
    return null;
  }
};
ContentParser.MEDIA_EXTENSIONS = {
  audio: [".mp3", ".wav", ".m4a", ".aac", ".ogg", ".flac"],
  video: [".mp4", ".mov", ".avi", ".mkv", ".webm", ".m4v"],
  image: [".jpg", ".jpeg", ".png", ".gif", ".webp", ".svg"],
  document: [".pdf", ".doc", ".docx", ".txt", ".rtf"]
};

// src/imageGenerator.ts
init_styleManager();

// src/htmlTemplateGenerator.ts
var HTMLTemplateGenerator = class {
  generateTemplate(style, content) {
    const currentDate = content.date || new Date();
    const formattedDate = this.formatDate(currentDate, style.id);
    return `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${content.title}</title>
    <link href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <link href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-100-M/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        ${this.generateCSS(style)}
    </style>
</head>
<body>
    <div class="magazine-card">
        ${this.generateContent(style, content, formattedDate)}
    </div>
    ${this.generateJavaScript(style)}
</body>
</html>`;
  }
  formatDate(date, styleId) {
    const options = {
      year: "numeric",
      month: "long",
      day: "numeric"
    };
    switch (styleId) {
      case "elegant-vintage":
      case "victorian":
        return date.toLocaleDateString("zh-CN", {
          year: "numeric",
          month: "long",
          day: "numeric",
          weekday: "long"
        });
      case "futuristic-tech":
      case "cyberpunk":
        return `${date.getFullYear()}.${String(date.getMonth() + 1).padStart(2, "0")}.${String(date.getDate()).padStart(2, "0")}`;
      default:
        return date.toLocaleDateString("zh-CN", options);
    }
  }
  generateCSS(style) {
    const baseCSS = `
      :root {
        --primary: ${style.colors.primary};
        --secondary: ${style.colors.secondary};
        --accent: ${style.colors.accent};
        --background: ${style.colors.background};
        --text: ${style.colors.text};
        --heading-font: ${style.fonts.heading};
        --body-font: ${style.fonts.body};
      }
      
      * {
        box-sizing: border-box;
      }
      
      body {
        margin: 0;
        padding: 20px;
        font-family: var(--body-font);
        background: var(--background);
        color: var(--text);
      }
      
      .magazine-card {
        width: 440px;
        min-height: 600px;
        max-height: 1280px;
        margin: 0 auto;
        position: relative;
        overflow: hidden;
      }
    `;
    const styleSpecificCSS = this.getStyleSpecificCSS(style.id);
    return baseCSS + styleSpecificCSS;
  }
  getStyleSpecificCSS(styleId) {
    switch (styleId) {
      case "minimalist":
        return `
          .magazine-card {
            background: white;
            padding: 60px 40px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.05);
          }
          .date { font-size: 12px; color: #999; margin-bottom: 40px; letter-spacing: 2px; }
          .title { font-size: 28px; font-weight: 700; line-height: 1.2; margin-bottom: 20px; }
          .subtitle { font-size: 14px; color: #666; margin-bottom: 30px; }
          .content { font-size: 14px; line-height: 1.6; margin-bottom: 30px; }
          .quote { border-left: 2px solid #000; padding-left: 20px; font-style: italic; margin: 30px 0; }
          .key-points { list-style: none; padding: 0; }
          .key-points li { margin-bottom: 10px; padding-left: 20px; position: relative; }
          .key-points li:before { content: "\u2014"; position: absolute; left: 0; }
          .qr-section { display: flex; justify-content: space-between; align-items: center; margin-top: 40px; }
          .qr-code { width: 60px; height: 60px; opacity: 0.7; }
          .editor-note { font-size: 11px; color: #999; }
        `;
      case "bold-modern":
        return `
          .magazine-card {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 40px;
            position: relative;
            overflow: hidden;
          }
          .magazine-card::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 200px;
            height: 200px;
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            border-radius: 50%;
            transform: translate(50%, -50%);
            opacity: 0.1;
          }
          .date { 
            font-size: 14px; 
            color: var(--accent); 
            margin-bottom: 20px; 
            text-transform: uppercase; 
            letter-spacing: 3px;
            transform: rotate(-2deg);
          }
          .title { 
            font-size: 36px; 
            font-weight: 900; 
            line-height: 0.9; 
            margin-bottom: 15px;
            color: var(--primary);
            text-shadow: 2px 2px 0px var(--secondary);
            transform: skew(-5deg);
          }
          .subtitle { 
            font-size: 16px; 
            color: var(--accent); 
            margin-bottom: 25px;
            transform: rotate(1deg);
          }
          .content { 
            font-size: 14px; 
            line-height: 1.6; 
            margin-bottom: 25px;
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 10px;
          }
          .quote { 
            background: var(--primary);
            color: black;
            padding: 20px;
            margin: 25px 0;
            transform: rotate(-1deg);
            font-weight: bold;
          }
          .key-points { 
            list-style: none; 
            padding: 0; 
          }
          .key-points li { 
            margin-bottom: 12px; 
            padding: 10px 15px;
            background: rgba(255,255,255,0.1);
            border-left: 4px solid var(--secondary);
            transform: skew(2deg);
          }
          .qr-section { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-top: 30px;
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 15px;
          }
          .qr-code { width: 50px; height: 50px; filter: invert(1); }
          .editor-note { font-size: 12px; color: var(--accent); }
        `;
      case "elegant-vintage":
        return `
          .magazine-card {
            background: #faf0e6;
            padding: 50px 45px;
            border: 3px solid #8b4513;
            position: relative;
            background-image: 
              radial-gradient(circle at 20% 80%, rgba(139, 69, 19, 0.1) 0%, transparent 50%),
              radial-gradient(circle at 80% 20%, rgba(218, 165, 32, 0.1) 0%, transparent 50%);
          }
          .magazine-card::before {
            content: '';
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            bottom: 15px;
            border: 1px solid #daa520;
            pointer-events: none;
          }
          .magazine-card::after {
            content: '\u2766';
            position: absolute;
            top: 25px;
            right: 35px;
            font-size: 20px;
            color: #8b4513;
          }
          .date { 
            font-size: 13px; 
            color: #8b4513; 
            margin-bottom: 25px;
            text-align: center;
            text-transform: capitalize;
            letter-spacing: 1px;
          }
          .title { 
            font-size: 24px; 
            font-weight: 600; 
            line-height: 1.3; 
            margin-bottom: 15px;
            text-align: center;
            color: #2f1b14;
          }
          .subtitle { 
            font-size: 14px; 
            color: #8b4513; 
            margin-bottom: 25px;
            text-align: center;
            font-style: italic;
          }
          .content { 
            font-size: 13px; 
            line-height: 1.7; 
            margin-bottom: 25px;
            text-align: justify;
            text-indent: 20px;
          }
          .quote { 
            border: none;
            padding: 20px;
            margin: 25px 0;
            background: rgba(218, 165, 32, 0.1);
            font-style: italic;
            text-align: center;
            position: relative;
          }
          .quote::before { content: '"'; font-size: 30px; position: absolute; top: -5px; left: 10px; }
          .quote::after { content: '"'; font-size: 30px; position: absolute; bottom: -15px; right: 10px; }
          .key-points { 
            list-style: none; 
            padding: 0; 
          }
          .key-points li { 
            margin-bottom: 8px; 
            padding-left: 25px;
            position: relative;
            font-size: 13px;
          }
          .key-points li:before { 
            content: '\u2022'; 
            position: absolute; 
            left: 0; 
            color: #8b4513;
            font-size: 16px;
          }
          .qr-section { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #daa520;
          }
          .qr-code { width: 45px; height: 45px; opacity: 0.8; }
          .editor-note { font-size: 11px; color: #8b4513; font-style: italic; }
        `;
      case "futuristic-tech":
        return `
          .magazine-card {
            background: linear-gradient(135deg, #0a0a23 0%, #1a1a3a 100%);
            padding: 40px;
            border: 1px solid #00ffff;
            position: relative;
            overflow: hidden;
          }
          .magazine-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ffff, transparent);
            animation: scan 2s linear infinite;
          }
          @keyframes scan {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
          }
          .date { 
            font-size: 12px; 
            color: #00ff41; 
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-family: 'Courier New', monospace;
          }
          .title { 
            font-size: 22px; 
            font-weight: 700; 
            line-height: 1.2; 
            margin-bottom: 15px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            font-family: 'Courier New', monospace;
          }
          .subtitle { 
            font-size: 13px; 
            color: #8a2be2; 
            margin-bottom: 25px;
            font-family: 'Courier New', monospace;
          }
          .content { 
            font-size: 12px; 
            line-height: 1.6; 
            margin-bottom: 25px;
            background: rgba(0, 255, 255, 0.05);
            padding: 15px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            font-family: 'Courier New', monospace;
          }
          .quote { 
            background: rgba(138, 43, 226, 0.2);
            border-left: 3px solid #8a2be2;
            padding: 15px;
            margin: 25px 0;
            font-family: 'Courier New', monospace;
            color: #e6e6e6;
          }
          .key-points { 
            list-style: none; 
            padding: 0; 
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border: 1px solid rgba(0, 255, 65, 0.3);
          }
          .key-points li { 
            margin-bottom: 8px; 
            padding-left: 20px;
            position: relative;
            font-family: 'Courier New', monospace;
            font-size: 11px;
          }
          .key-points li:before { 
            content: '>';
            position: absolute; 
            left: 0; 
            color: #00ff41;
          }
          .qr-section { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-top: 25px;
            background: rgba(0, 0, 0, 0.5);
            padding: 12px;
            border: 1px solid #00ffff;
          }
          .qr-code { width: 40px; height: 40px; filter: invert(1) sepia(1) hue-rotate(180deg); }
          .editor-note { font-size: 10px; color: #00ff41; font-family: 'Courier New', monospace; }
        `;
      case "scandinavian":
        return `
          .magazine-card {
            background: white;
            padding: 50px 40px;
            box-shadow: 0 4px 30px rgba(0,0,0,0.08);
            border-radius: 12px;
          }
          .date { 
            font-size: 12px; 
            color: #666; 
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 300;
          }
          .title { 
            font-size: 26px; 
            font-weight: 500; 
            line-height: 1.3; 
            margin-bottom: 15px;
            color: #2c2c2c;
          }
          .subtitle { 
            font-size: 14px; 
            color: #4a90e2; 
            margin-bottom: 30px;
            font-weight: 400;
          }
          .content { 
            font-size: 14px; 
            line-height: 1.7; 
            margin-bottom: 30px;
            color: #444;
          }
          .quote { 
            background: #f5f5f5;
            border-left: 4px solid #4a90e2;
            padding: 20px;
            margin: 30px 0;
            border-radius: 0 8px 8px 0;
          }
          .key-points { 
            list-style: none; 
            padding: 0; 
            background: #fafafa;
            padding: 20px;
            border-radius: 8px;
          }
          .key-points li { 
            margin-bottom: 10px; 
            padding-left: 20px;
            position: relative;
            color: #555;
          }
          .key-points li:before { 
            content: '\u25CB';
            position: absolute; 
            left: 0; 
            color: #4a90e2;
          }
          .qr-section { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #eee;
          }
          .qr-code { width: 50px; height: 50px; opacity: 0.6; border-radius: 4px; }
          .editor-note { font-size: 12px; color: #888; }
        `;
      case "art-deco":
        return `
          .magazine-card {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 40px;
            border: 2px solid #d4af37;
            position: relative;
            overflow: hidden;
          }
          .magazine-card::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border: 1px solid #d4af37;
            pointer-events: none;
          }
          .magazine-card::after {
            content: '\u25C6';
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            color: #d4af37;
          }
          .date { 
            font-size: 12px; 
            color: #d4af37; 
            margin-bottom: 25px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-weight: 600;
          }
          .title { 
            font-size: 28px; 
            font-weight: 700; 
            line-height: 1.2; 
            margin-bottom: 15px;
            text-align: center;
            color: #d4af37;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.7);
          }
          .subtitle { 
            font-size: 14px; 
            color: white; 
            margin-bottom: 25px;
            text-align: center;
            font-style: italic;
          }
          .content { 
            font-size: 13px; 
            line-height: 1.6; 
            margin-bottom: 25px;
            text-align: justify;
            color: #e6e6e6;
          }
          .quote { 
            background: linear-gradient(45deg, #d4af37, #f4d03f);
            color: #1a1a1a;
            padding: 20px;
            margin: 25px 0;
            text-align: center;
            font-weight: bold;
            position: relative;
          }
          .quote::before, .quote::after {
            content: '\u25C6';
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            color: #1a1a1a;
          }
          .quote::before { left: 10px; }
          .quote::after { right: 10px; }
          .key-points { 
            list-style: none; 
            padding: 0; 
          }
          .key-points li { 
            margin-bottom: 10px; 
            padding-left: 25px;
            position: relative;
            color: #e6e6e6;
          }
          .key-points li:before { 
            content: '\u25B6';
            position: absolute; 
            left: 0; 
            color: #d4af37;
          }
          .qr-section { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-top: 30px;
            padding: 15px;
            border: 1px solid #d4af37;
            background: rgba(212, 175, 55, 0.1);
          }
          .qr-code { width: 45px; height: 45px; filter: brightness(0) invert(1) sepia(1) saturate(3) hue-rotate(35deg); }
          .editor-note { font-size: 11px; color: #d4af37; }
        `;
      case "japanese-minimalism":
        return `
          .magazine-card {
            background: #ffffff;
            padding: 60px 50px 60px 40px;
            position: relative;
            border-left: 1px solid #e8e8e8;
          }
          .magazine-card::before {
            content: '\u5370';
            position: absolute;
            top: 30px;
            right: 30px;
            width: 20px;
            height: 20px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #333;
          }
          .date { 
            writing-mode: vertical-rl;
            text-orientation: mixed;
            position: absolute;
            right: 15px;
            top: 80px;
            font-size: 11px; 
            color: #666; 
            letter-spacing: 2px;
          }
          .title { 
            font-size: 24px; 
            font-weight: 500; 
            line-height: 1.4; 
            margin-bottom: 40px;
            color: #2c2c2c;
            position: relative;
          }
          .title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 0;
            width: 30px;
            height: 1px;
            background: #333;
          }
          .subtitle { 
            font-size: 13px; 
            color: #666; 
            margin-bottom: 40px;
            font-weight: 300;
          }
          .content { 
            font-size: 13px; 
            line-height: 1.8; 
            margin-bottom: 40px;
            color: #444;
          }
          .quote { 
            border: none;
            padding: 0;
            margin: 40px 0;
            font-style: italic;
            color: #666;
            position: relative;
            padding-left: 20px;
          }
          .quote::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 1px;
            background: #ccc;
          }
          .key-points { 
            list-style: none; 
            padding: 0; 
          }
          .key-points li { 
            margin-bottom: 12px; 
            padding: 0;
            color: #555;
            font-size: 13px;
            position: relative;
            padding-left: 15px;
          }
          .key-points li:before { 
            content: '\u30FB';
            position: absolute; 
            left: 0;
            color: #999;
          }
          .qr-section { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #f0f0f0;
          }
          .qr-code { width: 40px; height: 40px; opacity: 0.5; }
          .editor-note { font-size: 10px; color: #999; }
        `;
      default:
        return `
          .magazine-card {
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
          }
          .date { font-size: 12px; color: #666; margin-bottom: 20px; }
          .title { font-size: 24px; font-weight: 600; margin-bottom: 15px; }
          .subtitle { font-size: 14px; color: #888; margin-bottom: 20px; }
          .content { font-size: 14px; line-height: 1.6; margin-bottom: 20px; }
          .quote { border-left: 3px solid #ddd; padding-left: 15px; margin: 20px 0; }
          .key-points { list-style-type: disc; padding-left: 20px; }
          .key-points li { margin-bottom: 8px; }
          .qr-section { display: flex; justify-content: space-between; align-items: center; margin-top: 30px; }
          .qr-code { width: 50px; height: 50px; }
          .editor-note { font-size: 12px; color: #999; }
        `;
    }
  }
  generateContent(style, content, formattedDate) {
    const keyPoints = content.keyPoints || this.extractKeyPoints(content.content);
    const limitedKeyPoints = keyPoints.slice(0, 4);
    const quote = content.quote || this.extractQuote(content.content);
    return `
      <div class="date">${formattedDate}</div>
      
      <h1 class="title">${content.title}</h1>
      
      ${content.subtitle ? `<h2 class="subtitle">${content.subtitle}</h2>` : ""}
      
      <div class="content">${this.truncateContent(content.content, 200)}</div>
      
      ${quote ? `<blockquote class="quote">${quote}</blockquote>` : ""}
      
      ${limitedKeyPoints.length > 0 ? `
        <ul class="key-points">
          ${limitedKeyPoints.map((point) => `<li>${point}</li>`).join("")}
        </ul>
      ` : ""}
      
      <div class="qr-section">
        <div class="editor-note">
          ${content.editorNote || "Microfeed \xB7 \u6570\u5B57\u6742\u5FD7"}
        </div>
        <img src="${content.qrCodeUrl}" alt="QR Code" class="qr-code" />
      </div>
    `;
  }
  extractKeyPoints(content) {
    const sentences = content.split(/[。！？.!?]/).filter((s) => s.trim().length > 10);
    return sentences.slice(0, 4).map((s) => s.trim() + "\u3002");
  }
  extractQuote(content) {
    const sentences = content.split(/[。！？.!?]/).filter((s) => s.trim().length > 20);
    return sentences.length > 0 ? sentences[0].trim() + "\u3002" : null;
  }
  truncateContent(content, maxLength) {
    if (content.length <= maxLength) {
      return content;
    }
    return content.substring(0, maxLength).trim() + "...";
  }
  generateJavaScript(style) {
    if (style.effects.includes("liquid-gradients") || style.id === "liquid-morphism") {
      return `
        <script>
        document.addEventListener('DOMContentLoaded', function() {
          const card = document.querySelector('.magazine-card');
          if (card) {
            card.style.background = 'linear-gradient(135deg, #8a2be2, #00bfff, #ff1493, #8a2be2)';
            card.style.backgroundSize = '200% 200%';
            card.style.animation = 'liquidFlow 6s ease-in-out infinite';
          }
          
          const style = document.createElement('style');
          style.textContent = \`
            @keyframes liquidFlow {
              0%, 100% { background-position: 0% 50%; }
              50% { background-position: 100% 50%; }
            }
          \`;
          document.head.appendChild(style);
        });
        <\/script>
      `;
    }
    if (style.effects.includes("glitch-effects") || style.id === "cyberpunk") {
      return `
        <script>
        document.addEventListener('DOMContentLoaded', function() {
          const title = document.querySelector('.title');
          if (title) {
            setInterval(() => {
              if (Math.random() < 0.1) {
                title.style.textShadow = '2px 0 #ff00ff, -2px 0 #00ffff';
                setTimeout(() => {
                  title.style.textShadow = '0 0 10px #00ffff';
                }, 100);
              }
            }, 500);
          }
        });
        <\/script>
      `;
    }
    return "<script><\/script>";
  }
};

// src/imageGenerator.ts
var import_obsidian4 = require("obsidian");
var ImageGenerator = class {
  constructor() {
    this.qrCodeBlob = null;
    this.canvas = document.createElement("canvas");
    this.canvas.width = 1400;
    this.canvas.height = 1400;
    this.ctx = this.canvas.getContext("2d");
    this.templateGenerator = new HTMLTemplateGenerator();
    this.preloadQRCode();
  }
  async generateThumbnail(title, content) {
    const ctx = this.ctx;
    const width = this.canvas.width;
    const height = this.canvas.height;
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, width, height);
    this.drawBentoGrid(ctx, width, height);
    await this.drawTitle(ctx, title, width, height);
    await this.drawContent(ctx, content, width, height);
    this.drawDecorations(ctx, width, height);
    return new Promise((resolve) => {
      this.canvas.toBlob((blob) => {
        resolve(blob);
      }, "image/png", 0.9);
    });
  }
  async drawTitle(ctx, title, width, height) {
    ctx.fillStyle = "#1e293b";
    ctx.font = 'bold 68px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    const padding = 80;
    const contentArea = {
      x: padding + 60,
      y: padding + 60,
      width: width - (padding + 60) * 2,
      height: height * 0.65 - padding - 120
    };
    const words = title.split(" ");
    const lines = [];
    let currentLine = "";
    const maxWidth = contentArea.width;
    for (const word of words) {
      const testLine = currentLine + (currentLine ? " " : "") + word;
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && currentLine) {
        lines.push(currentLine);
        currentLine = word;
      } else {
        currentLine = testLine;
      }
    }
    if (currentLine) {
      lines.push(currentLine);
    }
    const lineHeight = 76;
    lines.forEach((line, index) => {
      const y = contentArea.y + index * lineHeight;
      ctx.fillText(line, contentArea.x, y);
    });
  }
  async drawContent(ctx, content, width, height) {
    const cleanContent = content.replace(/[#*_`]/g, "").replace(/\n+/g, " ").trim();
    const preview = cleanContent.length > 180 ? cleanContent.substring(0, 180) + "..." : cleanContent;
    if (!preview)
      return;
    const padding = 80;
    const contentArea = {
      x: padding + 60,
      y: padding + 260,
      // Below title
      width: width - (padding + 60) * 2,
      height: height * 0.4
    };
    ctx.fillStyle = "#64748b";
    ctx.font = '28px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    const words = preview.split(" ");
    const lines = [];
    let currentLine = "";
    const maxWidth = contentArea.width;
    for (const word of words) {
      const testLine = currentLine + (currentLine ? " " : "") + word;
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && currentLine) {
        lines.push(currentLine);
        currentLine = word;
      } else {
        currentLine = testLine;
      }
    }
    if (currentLine) {
      lines.push(currentLine);
    }
    const displayLines = lines.slice(0, 4);
    const lineHeight = 36;
    displayLines.forEach((line, index) => {
      const y = contentArea.y + index * lineHeight;
      ctx.fillText(line, contentArea.x, y);
    });
  }
  drawBentoGrid(ctx, width, height) {
    const padding = 80;
    const cornerRadius = 32;
    this.drawRoundedRect(
      ctx,
      padding,
      padding,
      width - padding * 2,
      height * 0.65 - padding,
      cornerRadius,
      "#f8fafc",
      "#e2e8f0"
    );
    const cardWidth = (width - padding * 3) / 2 - 40;
    const cardHeight = height * 0.25;
    const cardY = height * 0.7;
    this.drawRoundedRect(
      ctx,
      padding,
      cardY,
      cardWidth,
      cardHeight,
      cornerRadius * 0.75,
      "#dbeafe",
      "#3b82f6"
    );
    this.drawRoundedRect(
      ctx,
      padding + cardWidth + 40,
      cardY,
      cardWidth,
      cardHeight,
      cornerRadius * 0.75,
      "#eff6ff",
      "#60a5fa"
    );
  }
  drawRoundedRect(ctx, x, y, width, height, radius, fillColor, strokeColor) {
    ctx.beginPath();
    if (typeof ctx.roundRect === "function") {
      ctx.roundRect(x, y, width, height, radius);
    } else {
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }
    ctx.fillStyle = fillColor;
    ctx.fill();
    if (strokeColor) {
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }
  drawDecorations(ctx, width, height) {
    const padding = 80;
    const cardWidth = (width - padding * 3) / 2 - 40;
    const cardHeight = height * 0.25;
    const cardY = height * 0.7;
    ctx.fillStyle = "#3b82f6";
    ctx.font = 'bold 24px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    const leftCardCenterX = padding + 40;
    const leftCardCenterY = cardY + cardHeight / 2;
    ctx.fillText("\u{1F4DD}", leftCardCenterX, leftCardCenterY - 15);
    ctx.fillStyle = "#1e40af";
    ctx.font = '18px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.fillText("Microfeed", leftCardCenterX + 40, leftCardCenterY - 15);
    const rightCardCenterX = padding + cardWidth + 40 + 40;
    const rightCardCenterY = cardY + cardHeight / 2;
    ctx.fillStyle = "#60a5fa";
    ctx.font = 'bold 24px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.fillText("\u{1F4C5}", rightCardCenterX, rightCardCenterY - 15);
    ctx.fillStyle = "#1e40af";
    ctx.font = '18px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    const today = new Date().toLocaleDateString("en-US", {
      month: "short",
      day: "numeric"
    });
    ctx.fillText(today, rightCardCenterX + 40, rightCardCenterY - 15);
    ctx.fillStyle = "#3b82f6";
    ctx.beginPath();
    ctx.arc(width - padding - 40, padding + 40, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#60a5fa";
    ctx.beginPath();
    ctx.arc(width - padding - 60, padding + 40, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#93c5fd";
    ctx.beginPath();
    ctx.arc(width - padding - 80, padding + 40, 2, 0, Math.PI * 2);
    ctx.fill();
  }
  async generateMagazineStyleImage(title, content, styleId) {
    try {
      const style = styleId ? getStyleById(styleId) || getRandomStyle() : getRandomStyle();
      console.log(`Generating image with style: ${style.name} (${style.id})`);
      return this.generateCanvasStyleImage(title, content, style);
    } catch (error) {
      console.error("Failed to generate magazine style image:", error);
      return this.generateThumbnail(title, content);
    }
  }
  async generateCanvasStyleImage(title, content, style) {
    const ctx = this.ctx;
    const width = this.canvas.width;
    const height = this.canvas.height;
    switch (style.id) {
      case "minimalist":
        return this.drawMinimalistStyle(ctx, width, height, title, content);
      case "bold-modern":
        return this.drawBoldModernStyle(ctx, width, height, title, content);
      case "elegant-vintage":
        return this.drawElegantVintageStyle(ctx, width, height, title, content);
      case "futuristic-tech":
        return this.drawFuturisticTechStyle(ctx, width, height, title, content);
      case "punk":
        return this.drawPunkStyle(ctx, width, height, title, content);
      case "japanese-minimalism":
        return this.drawJapaneseMinimalismStyle(ctx, width, height, title, content);
      case "art-deco":
        return this.drawArtDecoStyle(ctx, width, height, title, content);
      case "cyberpunk":
        return this.drawCyberpunkStyle(ctx, width, height, title, content);
      default:
        return this.drawDefaultStyleVariation(ctx, width, height, title, content, style);
    }
  }
  async waitForFontsAndStyles(container) {
    if ("fonts" in document && document.fonts.ready) {
      await document.fonts.ready;
    }
    await new Promise((resolve) => setTimeout(resolve, 500));
    const images = container.querySelectorAll("img");
    const imagePromises = Array.from(images).map((img) => {
      return new Promise((resolve) => {
        if (img.complete) {
          resolve(true);
        } else {
          img.onload = () => resolve(true);
          img.onerror = () => resolve(true);
          setTimeout(() => resolve(true), 2e3);
        }
      });
    });
    await Promise.all(imagePromises);
  }
  // 保留原有的方法作为备用
  async generateFromElement(element) {
    const { toPng: toPng2 } = await Promise.resolve().then(() => (init_es(), es_exports));
    try {
      const dataUrl = await toPng2(element, {
        width: 1400,
        height: 1400,
        backgroundColor: "#1a1a1a"
      });
      const response = await fetch(dataUrl);
      return await response.blob();
    } catch (error) {
      console.error("Failed to generate image from element:", error);
      throw error;
    }
  }
  // 获取可用的设计风格列表
  getAvailableStyles() {
    const { DESIGN_STYLES: DESIGN_STYLES2 } = (init_styleManager(), __toCommonJS(styleManager_exports));
    return DESIGN_STYLES2;
  }
  // 生成指定风格的图片
  async generateWithStyle(title, content, styleId) {
    return this.generateMagazineStyleImage(title, content, styleId);
  }
  // 生成随机风格的图片
  async generateRandomStyle(title, content) {
    const randomStyle = getRandomStyle();
    console.log(`\u{1F3B2} Random style selected: ${randomStyle.name} (${randomStyle.id})`);
    const cleanedContent = this.cleanContentForDisplay(content);
    console.log(`\u{1F4DD} Content length: ${cleanedContent.length} characters`);
    return this.generateCanvasStyleImage(title, cleanedContent, randomStyle);
  }
  // 极简主义风格
  async drawMinimalistStyle(ctx, width, height, title, content) {
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, width, height);
    ctx.fillStyle = "#000000";
    ctx.font = "normal 72px -apple-system, BlinkMacSystemFont, sans-serif";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    const titleLines = this.wrapText(ctx, title, width * 0.7);
    titleLines.forEach((line, index) => {
      ctx.fillText(line, width * 0.15, height * 0.2 + index * 70);
    });
    ctx.fillStyle = "#666666";
    ctx.font = "28px -apple-system, BlinkMacSystemFont, sans-serif";
    const contentLines = this.wrapText(ctx, content.substring(0, 300), width * 0.55);
    const maxLines = Math.min(contentLines.length, 6);
    contentLines.slice(0, maxLines).forEach((line, index) => {
      ctx.fillText(line, width * 0.15, height * 0.48 + index * 34);
    });
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(width * 0.15, height * 0.45);
    ctx.lineTo(width * 0.25, height * 0.45);
    ctx.stroke();
    const bottomY = height * 0.85;
    ctx.fillStyle = "#cccccc";
    ctx.font = "16px -apple-system, BlinkMacSystemFont, sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("Microfeed \xB7 \u6570\u5B57\u6742\u5FD7", width * 0.15, bottomY);
    await this.drawQRCode(ctx, width * 0.82, bottomY - 45, 80);
    return this.canvasToBlob();
  }
  // 大胆现代风格
  async drawBoldModernStyle(ctx, width, height, title, content) {
    ctx.fillStyle = "#1a1a1a";
    ctx.fillRect(0, 0, width, height);
    ctx.fillStyle = "#ff0080";
    ctx.beginPath();
    ctx.arc(width * 0.8, height * 0.2, 120, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#00ffff";
    ctx.beginPath();
    ctx.rect(width * 0.05, height * 0.7, 200, 100);
    ctx.fill();
    ctx.fillStyle = "#ffffff";
    ctx.font = "bold 84px -apple-system, BlinkMacSystemFont, sans-serif";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.shadowColor = "#ff0080";
    ctx.shadowOffsetX = 4;
    ctx.shadowOffsetY = 4;
    ctx.shadowBlur = 0;
    const titleLines = this.wrapText(ctx, title, width * 0.8);
    titleLines.forEach((line, index) => {
      ctx.fillText(line, width * 0.1, height * 0.25 + index * 80);
    });
    ctx.shadowColor = "transparent";
    ctx.fillStyle = "#cccccc";
    ctx.font = "32px -apple-system, BlinkMacSystemFont, sans-serif";
    const contentLines = this.wrapText(ctx, content.substring(0, 280), width * 0.45);
    const maxLines = Math.min(contentLines.length, 5);
    contentLines.slice(0, maxLines).forEach((line, index) => {
      ctx.fillText(line, width * 0.1, height * 0.52 + index * 38);
    });
    const bottomY = height * 0.9;
    ctx.fillStyle = "#ffffff";
    ctx.font = "bold 18px -apple-system, BlinkMacSystemFont, sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("DIGITAL MAGAZINE", width * 0.1, bottomY);
    await this.drawQRCode(ctx, width * 0.82, bottomY - 50, 90);
    return this.canvasToBlob();
  }
  // 朋克风格
  async drawPunkStyle(ctx, width, height, title, content) {
    const backgrounds = ["#f5f5f5", "#fafafa", "#f8f8f8"];
    ctx.fillStyle = backgrounds[Math.floor(Math.random() * backgrounds.length)];
    ctx.fillRect(0, 0, width, height);
    ctx.fillStyle = "#ff0000";
    const numTears = Math.floor(Math.random() * 15) + 10;
    for (let i = 0; i < numTears; i++) {
      const x = Math.random() * width;
      const y = Math.random() * height;
      const w = Math.random() * 50 + 10;
      const h = Math.random() * 20 + 5;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(Math.random() * Math.PI);
      ctx.fillRect(-w / 2, -h / 2, w, h);
      ctx.restore();
    }
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 8;
    ctx.strokeRect(20, 20, width - 40, height - 40);
    ctx.fillStyle = "#000000";
    ctx.font = "bold 68px -apple-system, BlinkMacSystemFont, sans-serif";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    const titleLines = this.wrapText(ctx, title.toUpperCase(), width * 0.8);
    titleLines.forEach((line, index) => {
      ctx.save();
      ctx.transform(1, 0, Math.random() * 0.1 - 0.05, 1, 0, 0);
      ctx.fillText(line, width * 0.1, height * 0.2 + index * 65);
      ctx.restore();
    });
    ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
    ctx.strokeStyle = "#cccccc";
    ctx.lineWidth = 2;
    ctx.save();
    ctx.translate(width * 0.7, height * 0.15);
    ctx.rotate(0.3);
    ctx.fillRect(-40, -10, 80, 20);
    ctx.strokeRect(-40, -10, 80, 20);
    ctx.restore();
    ctx.fillStyle = "#333333";
    ctx.font = "bold 26px -apple-system, BlinkMacSystemFont, sans-serif";
    const contentLines = this.wrapText(ctx, content.substring(0, 250), width * 0.5);
    const maxLines = Math.min(contentLines.length, 6);
    contentLines.slice(0, maxLines).forEach((line, index) => {
      ctx.fillText(line, width * 0.1, height * 0.52 + index * 32);
    });
    const bottomY = height * 0.85;
    ctx.fillStyle = "#000000";
    ctx.fillRect(width * 0.1, bottomY - 15, width * 0.8, 40);
    ctx.fillStyle = "#ffffff";
    ctx.font = "bold 16px -apple-system, BlinkMacSystemFont, sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("UNDERGROUND ZINE", width * 0.15, bottomY + 5);
    await this.drawQRCode(ctx, width * 0.78, bottomY - 30, 75);
    return this.canvasToBlob();
  }
  // 赛博朋克风格
  async drawCyberpunkStyle(ctx, width, height, title, content) {
    ctx.fillStyle = "#0a0a23";
    ctx.fillRect(0, 0, width, height);
    ctx.strokeStyle = "rgba(0, 255, 255, 0.2)";
    ctx.lineWidth = 1;
    for (let i = 0; i < width; i += 50) {
      ctx.beginPath();
      ctx.moveTo(i, 0);
      ctx.lineTo(i, height);
      ctx.stroke();
    }
    for (let i = 0; i < height; i += 50) {
      ctx.beginPath();
      ctx.moveTo(0, i);
      ctx.lineTo(width, i);
      ctx.stroke();
    }
    ctx.fillStyle = "#00ffff";
    ctx.font = "bold 68px monospace";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.shadowColor = "#00ffff";
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.shadowBlur = 20;
    const titleLines = this.wrapText(ctx, title.toUpperCase(), width * 0.8);
    titleLines.forEach((line, index) => {
      ctx.fillText(line, width * 0.1, height * 0.2 + index * 65);
    });
    ctx.shadowColor = "transparent";
    ctx.strokeStyle = "rgba(255, 0, 255, 0.3)";
    ctx.lineWidth = 2;
    for (let i = 0; i < height; i += 4) {
      ctx.beginPath();
      ctx.moveTo(0, i);
      ctx.lineTo(width, i);
      ctx.stroke();
    }
    ctx.fillStyle = "#e6e6e6";
    ctx.font = "28px monospace";
    const contentLines = this.wrapText(ctx, content.substring(0, 240), width * 0.5);
    const maxLines = Math.min(contentLines.length, 5);
    contentLines.slice(0, maxLines).forEach((line, index) => {
      ctx.fillText(line, width * 0.1, height * 0.52 + index * 34);
    });
    const bottomY = height * 0.85;
    ctx.strokeStyle = "#00ffff";
    ctx.lineWidth = 2;
    ctx.strokeRect(width * 0.1, bottomY - 20, width * 0.8, 35);
    ctx.fillStyle = "#00ffff";
    ctx.shadowColor = "#00ffff";
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.shadowBlur = 10;
    ctx.font = "bold 14px monospace";
    ctx.textAlign = "left";
    ctx.fillText(">>> NEURAL.LINK.ACTIVE", width * 0.15, bottomY - 2);
    ctx.shadowColor = "transparent";
    await this.drawQRCode(ctx, width * 0.78, bottomY - 32, 70);
    return this.canvasToBlob();
  }
  // 默认风格变体（用于其他风格）
  async drawDefaultStyleVariation(ctx, width, height, title, content, style) {
    ctx.fillStyle = style.colors.background;
    ctx.fillRect(0, 0, width, height);
    ctx.fillStyle = style.colors.primary;
    ctx.font = "bold 62px -apple-system, BlinkMacSystemFont, sans-serif";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    const titleLines = this.wrapText(ctx, title, width * 0.8);
    titleLines.forEach((line, index) => {
      ctx.fillText(line, width * 0.1, height * 0.2 + index * 60);
    });
    ctx.fillStyle = style.colors.accent;
    ctx.beginPath();
    ctx.arc(width * 0.85, height * 0.15, 40, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = style.colors.text;
    ctx.font = "28px -apple-system, BlinkMacSystemFont, sans-serif";
    const contentLines = this.wrapText(ctx, content.substring(0, 300), width * 0.5);
    const maxLines = Math.min(contentLines.length, 6);
    contentLines.slice(0, maxLines).forEach((line, index) => {
      ctx.fillText(line, width * 0.1, height * 0.48 + index * 34);
    });
    const bottomY = height * 0.9;
    ctx.fillStyle = style.colors.secondary;
    ctx.font = "14px -apple-system, BlinkMacSystemFont, sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(`${style.name} \xB7 Microfeed`, width * 0.1, bottomY);
    await this.drawQRCode(ctx, width * 0.82, bottomY - 45, 80);
    return this.canvasToBlob();
  }
  // 清理内容用于显示
  cleanContentForDisplay(content) {
    return content.replace(/^#{1,6}\s+/gm, "").replace(/\*\*(.*?)\*\*/g, "$1").replace(/\*(.*?)\*/g, "$1").replace(/`(.*?)`/g, "$1").replace(/\[([^\]]+)\]\([^)]+\)/g, "$1").replace(/!\[([^\]]*)\]\([^)]+\)/g, "").replace(/^[-*+]\s+/gm, "").replace(/^\d+\.\s+/gm, "").replace(/^>\s+/gm, "").replace(/```[\s\S]*?```/g, "").replace(/`([^`]+)`/g, "$1").replace(/\n\s*\n\s*\n/g, "\n\n").replace(/^\s+|\s+$/g, "").replace(/\s+/g, " ").trim();
  }
  // 辅助方法：文本换行（改进版，支持中文和强制换行）
  wrapText(ctx, text, maxWidth) {
    const lines = [];
    let currentLine = "";
    const segments = text.split(/(\s+)/);
    for (const segment of segments) {
      if (segment.trim() === "")
        continue;
      const testLine = currentLine + segment;
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && currentLine.trim()) {
        lines.push(currentLine.trim());
        currentLine = segment;
        while (ctx.measureText(currentLine).width > maxWidth && currentLine.length > 1) {
          let breakPoint = currentLine.length - 1;
          while (breakPoint > 0 && ctx.measureText(currentLine.substring(0, breakPoint)).width > maxWidth) {
            breakPoint--;
          }
          if (breakPoint === 0)
            breakPoint = 1;
          lines.push(currentLine.substring(0, breakPoint).trim());
          currentLine = currentLine.substring(breakPoint);
        }
      } else {
        currentLine = testLine;
      }
    }
    if (currentLine.trim()) {
      while (ctx.measureText(currentLine).width > maxWidth && currentLine.length > 1) {
        let breakPoint = currentLine.length - 1;
        while (breakPoint > 0 && ctx.measureText(currentLine.substring(0, breakPoint)).width > maxWidth) {
          breakPoint--;
        }
        if (breakPoint === 0)
          breakPoint = 1;
        lines.push(currentLine.substring(0, breakPoint).trim());
        currentLine = currentLine.substring(breakPoint);
      }
      if (currentLine.trim()) {
        lines.push(currentLine.trim());
      }
    }
    return lines;
  }
  // 优雅复古风格
  async drawElegantVintageStyle(ctx, width, height, title, content) {
    ctx.fillStyle = "#faf0e6";
    ctx.fillRect(0, 0, width, height);
    ctx.strokeStyle = "#8b4513";
    ctx.lineWidth = 6;
    ctx.strokeRect(40, 40, width - 80, height - 80);
    ctx.strokeStyle = "#daa520";
    ctx.lineWidth = 2;
    ctx.strokeRect(50, 50, width - 100, height - 100);
    ctx.fillStyle = "#8b4513";
    ctx.font = "32px serif";
    ctx.textAlign = "center";
    ctx.fillText("\u2766", width / 2, 120);
    ctx.fillStyle = "#2f1b14";
    ctx.font = "bold 64px serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    const titleLines = this.wrapText(ctx, title, width * 0.6);
    titleLines.slice(0, 2).forEach((line, index) => {
      ctx.fillText(line, width / 2, height * 0.18 + index * 72);
    });
    ctx.strokeStyle = "#daa520";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(width * 0.2, height * 0.42);
    ctx.lineTo(width * 0.8, height * 0.42);
    ctx.stroke();
    ctx.fillStyle = "#4a3728";
    ctx.font = "24px serif";
    ctx.textAlign = "center";
    const contentLines = this.wrapText(ctx, content.substring(0, 280), width * 0.5);
    const maxLines = Math.min(contentLines.length, 5);
    contentLines.slice(0, maxLines).forEach((line, index) => {
      ctx.fillText(line, width / 2, height * 0.48 + index * 32);
    });
    const bottomY = height * 0.85;
    ctx.strokeStyle = "#8b4513";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(width * 0.15, bottomY - 10);
    ctx.lineTo(width * 0.85, bottomY - 10);
    ctx.stroke();
    ctx.fillStyle = "#8b4513";
    ctx.font = "18px serif";
    ctx.textAlign = "left";
    ctx.fillText("\u4F18\u96C5\u590D\u53E4\u6742\u5FD7 \xB7 Microfeed", width * 0.15, bottomY + 10);
    await this.drawQRCode(ctx, width * 0.82, bottomY - 30, 75);
    return this.canvasToBlob();
  }
  // 未来科技风格
  async drawFuturisticTechStyle(ctx, width, height, title, content) {
    ctx.fillStyle = "#0a0a23";
    ctx.fillRect(0, 0, width, height);
    ctx.strokeStyle = "rgba(0, 255, 65, 0.3)";
    ctx.lineWidth = 1;
    for (let i = 0; i < 10; i++) {
      const x1 = Math.random() * width;
      const y1 = Math.random() * height;
      const x2 = Math.random() * width;
      const y2 = Math.random() * height;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }
    ctx.strokeStyle = "#00ffff";
    ctx.lineWidth = 2;
    ctx.strokeRect(50, 50, width - 100, height - 100);
    const cornerSize = 30;
    ctx.beginPath();
    ctx.moveTo(50, 50 + cornerSize);
    ctx.lineTo(50, 50);
    ctx.lineTo(50 + cornerSize, 50);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(width - 50 - cornerSize, 50);
    ctx.lineTo(width - 50, 50);
    ctx.lineTo(width - 50, 50 + cornerSize);
    ctx.stroke();
    ctx.fillStyle = "#00ffff";
    ctx.font = "bold 50px monospace";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.shadowColor = "#00ffff";
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.shadowBlur = 15;
    const titleLines = this.wrapText(ctx, title.toUpperCase(), width * 0.7);
    titleLines.forEach((line, index) => {
      ctx.fillText(line, width * 0.1, height * 0.2 + index * 60);
    });
    ctx.shadowColor = "transparent";
    const dataColors = ["#00ff41", "#00ffff", "#ff00ff"];
    const numDots = Math.floor(Math.random() * 40) + 30;
    for (let i = 0; i < numDots; i++) {
      ctx.fillStyle = dataColors[Math.floor(Math.random() * dataColors.length)];
      const x = Math.random() * width;
      const y = Math.random() * height;
      const size = Math.random() * 3 + 1;
      ctx.fillRect(x, y, size, size);
    }
    ctx.fillStyle = "#e6e6e6";
    ctx.font = "26px monospace";
    const contentLines = this.wrapText(ctx, content.substring(0, 260), width * 0.5);
    const maxLines = Math.min(contentLines.length, 5);
    contentLines.slice(0, maxLines).forEach((line, index) => {
      ctx.fillText(line, width * 0.1, height * 0.48 + index * 32);
    });
    const bottomY = height * 0.85;
    ctx.strokeStyle = "#00ffff";
    ctx.lineWidth = 2;
    ctx.strokeRect(width * 0.1, bottomY - 20, width * 0.8, 35);
    ctx.fillStyle = "#00ffff";
    ctx.shadowColor = "#00ffff";
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.shadowBlur = 10;
    ctx.font = "bold 16px monospace";
    ctx.textAlign = "left";
    ctx.fillText(">>> FUTURE.TECH.MAGAZINE", width * 0.15, bottomY - 2);
    ctx.shadowColor = "transparent";
    await this.drawQRCode(ctx, width * 0.78, bottomY - 32, 70);
    return this.canvasToBlob();
  }
  // 日式极简风格
  async drawJapaneseMinimalismStyle(ctx, width, height, title, content) {
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, width, height);
    ctx.strokeStyle = "#333333";
    ctx.lineWidth = 2;
    ctx.strokeRect(width - 80, 50, 30, 30);
    ctx.fillStyle = "#333333";
    ctx.font = "16px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("\u5370", width - 65, 70);
    ctx.fillStyle = "#666666";
    ctx.font = "12px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("\u4EE4\u548C\u516D\u5E74", width - 40, 120);
    ctx.fillStyle = "#2c2c2c";
    ctx.font = "normal 42px sans-serif";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    const titleLines = this.wrapText(ctx, title, width * 0.7);
    titleLines.forEach((line, index) => {
      ctx.fillText(line, width * 0.1, height * 0.2 + index * 50);
    });
    ctx.strokeStyle = "#333333";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(width * 0.1, height * 0.4);
    ctx.lineTo(width * 0.15, height * 0.4);
    ctx.stroke();
    ctx.fillStyle = "#444444";
    ctx.font = "20px sans-serif";
    const contentLines = this.wrapText(ctx, content.substring(0, 350), width * 0.6);
    const maxLines = Math.min(contentLines.length, 8);
    contentLines.slice(0, maxLines).forEach((line, index) => {
      ctx.fillText(line, width * 0.1, height * 0.48 + index * 28);
    });
    ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
    ctx.beginPath();
    ctx.arc(width * 0.8, height * 0.8, 15, 0, Math.PI * 2);
    ctx.fill();
    const bottomY = height * 0.9;
    ctx.strokeStyle = "#333333";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(width * 0.1, bottomY - 10);
    ctx.lineTo(width * 0.9, bottomY - 10);
    ctx.stroke();
    ctx.fillStyle = "#666666";
    ctx.font = "16px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("\u65E5\u5F0F\u6781\u7B80\u96C5\u5FD7 \xB7 Microfeed", width * 0.1, bottomY + 5);
    await this.drawQRCode(ctx, width * 0.82, bottomY - 30, 70);
    return this.canvasToBlob();
  }
  // 艺术装饰风格
  async drawArtDecoStyle(ctx, width, height, title, content) {
    ctx.fillStyle = "#1a1a1a";
    ctx.fillRect(0, 0, width, height);
    ctx.fillStyle = "#d4af37";
    const centerX = width / 2;
    const centerY = height * 0.15;
    ctx.beginPath();
    for (let i = 0; i < 8; i++) {
      const angle = i * Math.PI * 2 / 8;
      const x2 = centerX + Math.cos(angle) * 50;
      const y2 = centerY + Math.sin(angle) * 50;
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(x2, y2);
    }
    ctx.strokeStyle = "#d4af37";
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.strokeStyle = "#d4af37";
    ctx.lineWidth = 4;
    ctx.strokeRect(30, 30, width - 60, height - 60);
    ctx.strokeRect(40, 40, width - 80, height - 80);
    ctx.fillStyle = "#d4af37";
    ctx.font = "bold 52px sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
    ctx.shadowOffsetX = 3;
    ctx.shadowOffsetY = 3;
    ctx.shadowBlur = 0;
    const titleLines = this.wrapText(ctx, title.toUpperCase(), width * 0.7);
    titleLines.forEach((line, index) => {
      ctx.fillText(line, width / 2, height * 0.25 + index * 60);
    });
    ctx.shadowColor = "transparent";
    ctx.fillStyle = "#d4af37";
    ctx.beginPath();
    ctx.moveTo(width * 0.3, height * 0.5);
    ctx.lineTo(width * 0.35, height * 0.48);
    ctx.lineTo(width * 0.4, height * 0.5);
    ctx.lineTo(width * 0.35, height * 0.52);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(width * 0.6, height * 0.5);
    ctx.lineTo(width * 0.65, height * 0.48);
    ctx.lineTo(width * 0.7, height * 0.5);
    ctx.lineTo(width * 0.65, height * 0.52);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#ffffff";
    ctx.font = "28px sans-serif";
    ctx.textAlign = "center";
    const contentLines = this.wrapText(ctx, content.substring(0, 250), width * 0.5);
    const maxLines = Math.min(contentLines.length, 4);
    contentLines.slice(0, maxLines).forEach((line, index) => {
      ctx.fillText(line, width / 2, height * 0.58 + index * 34);
    });
    const bottomY = height * 0.88;
    ctx.strokeStyle = "#d4af37";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(width * 0.15, bottomY - 15);
    ctx.lineTo(width * 0.85, bottomY - 15);
    ctx.stroke();
    ctx.fillStyle = "#d4af37";
    ctx.font = "bold 18px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("\u827A\u672F\u88C5\u9970\u6742\u5FD7 \xB7 Microfeed", width * 0.15, bottomY + 5);
    await this.drawQRCode(ctx, width * 0.82, bottomY - 35, 75);
    return this.canvasToBlob();
  }
  // 预加载QR码图片到本地
  async preloadQRCode() {
    try {
      console.log("\u{1F504} Preloading QR code image...");
      const qrUrl = "https://cdn.titi.li/titi-li/production/media/image-c9127e43a0a860fe555a62a8fce628ad.jpg";
      const response = await (0, import_obsidian4.requestUrl)({
        url: qrUrl,
        method: "GET",
        headers: {
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
        }
      });
      if (response.status >= 200 && response.status < 300) {
        this.qrCodeBlob = new Blob([response.arrayBuffer], { type: "image/jpeg" });
        console.log("\u2705 QR code image preloaded successfully via requestUrl");
        console.log(`\u{1F4CA} QR code blob size: ${this.qrCodeBlob.size} bytes`);
      } else {
        console.warn("\u26A0\uFE0F Failed to preload QR code image:", response.status);
      }
    } catch (error) {
      console.warn("\u26A0\uFE0F Error preloading QR code with requestUrl:", error);
      try {
        console.log("\u{1F504} Trying fallback with fetch API...");
        const response = await fetch("https://cdn.titi.li/titi-li/production/media/image-c9127e43a0a860fe555a62a8fce628ad.jpg", {
          mode: "cors",
          headers: {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
          }
        });
        if (response.ok) {
          this.qrCodeBlob = await response.blob();
          console.log("\u2705 QR code image preloaded successfully via fetch fallback");
          console.log(`\u{1F4CA} QR code blob size: ${this.qrCodeBlob.size} bytes`);
        } else {
          console.warn("\u26A0\uFE0F Fetch fallback also failed:", response.status);
        }
      } catch (fetchError) {
        console.error("\u274C Both requestUrl and fetch failed for QR code:", fetchError);
      }
    }
  }
  // 从Blob创建图片对象
  async createImageFromBlob(blob) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      const objectUrl = URL.createObjectURL(blob);
      img.onload = () => {
        URL.revokeObjectURL(objectUrl);
        resolve(img);
      };
      img.onerror = () => {
        URL.revokeObjectURL(objectUrl);
        reject(new Error("Failed to create image from blob"));
      };
      img.src = objectUrl;
    });
  }
  // 辅助方法：绘制二维码
  async drawQRCode(ctx, x, y, size = 50) {
    console.log(`\u{1F50D} Starting QR code rendering at (${x}, ${y}) with size ${size}`);
    try {
      let qrImage;
      if (this.qrCodeBlob && this.qrCodeBlob.size > 0) {
        console.log(`\u{1F4F1} Using preloaded QR code from local blob (${this.qrCodeBlob.size} bytes)`);
        qrImage = await this.createImageFromBlob(this.qrCodeBlob);
        console.log(`\u{1F5BC}\uFE0F QR image created: ${qrImage.width}x${qrImage.height}`);
      } else {
        console.log("\u{1F504} QR code not preloaded, attempting to fetch...");
        await this.preloadQRCode();
        if (this.qrCodeBlob && this.qrCodeBlob.size > 0) {
          console.log(`\u{1F4F1} Successfully fetched QR code (${this.qrCodeBlob.size} bytes)`);
          qrImage = await this.createImageFromBlob(this.qrCodeBlob);
          console.log(`\u{1F5BC}\uFE0F QR image created: ${qrImage.width}x${qrImage.height}`);
        } else {
          throw new Error("Failed to load QR code - no blob data");
        }
      }
      ctx.save();
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(x - 2, y - 2, size + 4, size + 4);
      ctx.drawImage(qrImage, x, y, size, size);
      ctx.restore();
      console.log(`\u2705 QR code rendered successfully at (${x}, ${y})`);
    } catch (error) {
      console.warn("\u26A0\uFE0F QR\u7801\u6E32\u67D3\u5931\u8D25\uFF0C\u4F7F\u7528\u5360\u4F4D\u7B26:", error);
      console.log("\u{1F3A8} Drawing QR code placeholder...");
      ctx.save();
      ctx.fillStyle = "#f8f8f8";
      ctx.fillRect(x, y, size, size);
      ctx.strokeStyle = "#d0d0d0";
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, size, size);
      ctx.fillStyle = "#888888";
      const iconSize = size * 0.7;
      const iconX = x + (size - iconSize) / 2;
      const iconY = y + (size - iconSize) / 2;
      const blockSize = iconSize / 8;
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if ((i + j) % 2 === 0 || i < 3 && j < 3 || i > 4 && j < 3 || i < 3 && j > 4) {
            ctx.fillRect(iconX + i * blockSize, iconY + j * blockSize, blockSize - 1, blockSize - 1);
          }
        }
      }
      ctx.fillStyle = "#666666";
      ctx.font = `${Math.floor(size * 0.2)}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("QR", x + size / 2, y + size * 0.8);
      ctx.restore();
      console.log(`\u{1F3A8} QR placeholder rendered at (${x}, ${y})`);
    }
  }
  // 辅助方法：Canvas转Blob
  async canvasToBlob() {
    return new Promise((resolve) => {
      this.canvas.toBlob((blob) => {
        resolve(blob);
      }, "image/png", 0.9);
    });
  }
};

// main.ts
init_twitterClient();
var MicrofeedPlugin = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.imageGenerator = new ImageGenerator();
    const ribbonIconEl = this.addRibbonIcon("upload", "Publish to Microfeed", (evt) => {
      this.publishCurrentNote();
    });
    ribbonIconEl.addClass("microfeed-ribbon-class");
    this.addCommand({
      id: "publish-to-microfeed",
      name: "Publish to Microfeed",
      callback: () => {
        this.publishCurrentNote();
      }
    });
    this.addCommand({
      id: "publish-to-microfeed-with-options",
      name: "Publish to Microfeed with options",
      callback: () => {
        this.publishWithOptions();
      }
    });
    this.addCommand({
      id: "generate-magazine-preview",
      name: "Generate Magazine Style Preview",
      callback: () => {
        this.generateMagazinePreview();
      }
    });
    this.addCommand({
      id: "test-all-magazine-styles",
      name: "Test All Magazine Styles",
      callback: () => {
        this.testAllMagazineStyles();
      }
    });
    this.addCommand({
      id: "post-to-twitter",
      name: "Post to Twitter/X",
      callback: () => {
        this.postToTwitter();
      }
    });
    this.addCommand({
      id: "publish-to-microfeed-and-twitter",
      name: "Publish to Microfeed and Twitter/X",
      callback: () => {
        this.publishToMicrofeedAndTwitter();
      }
    });
    this.addSettingTab(new MicrofeedSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async publishCurrentNote() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (!activeView) {
      new import_obsidian5.Notice("No active markdown note found");
      return;
    }
    const file = activeView.file;
    if (!file) {
      new import_obsidian5.Notice("No file found");
      return;
    }
    await this.publishNote(file);
  }
  async publishWithOptions() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (!activeView) {
      new import_obsidian5.Notice("No active markdown note found");
      return;
    }
    const file = activeView.file;
    if (!file) {
      new import_obsidian5.Notice("No file found");
      return;
    }
    new PublishOptionsModal(this.app, this, file).open();
  }
  async generateMagazinePreview() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (!activeView) {
      new import_obsidian5.Notice("No active markdown note found");
      return;
    }
    const file = activeView.file;
    if (!file) {
      new import_obsidian5.Notice("No file found");
      return;
    }
    new MagazineStyleModal(this.app, this, file).open();
  }
  async testAllMagazineStyles() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (!activeView) {
      new import_obsidian5.Notice("No active markdown note found");
      return;
    }
    const file = activeView.file;
    if (!file) {
      new import_obsidian5.Notice("No file found");
      return;
    }
    const notice = new import_obsidian5.Notice("\u6B63\u5728\u751F\u6210\u6240\u6709\u98CE\u683C\u7684\u9884\u89C8\u56FE\u7247...", 0);
    try {
      const content = await this.app.vault.read(file);
      const parsedContent = ContentParser.parseMarkdownContent(content, file.name);
      const styles = this.imageGenerator.getAvailableStyles();
      const results = [];
      for (const style of styles.slice(0, 5)) {
        try {
          const imageBlob = await this.imageGenerator.generateWithStyle(
            parsedContent.title,
            parsedContent.content,
            style.id
          );
          results.push({ styleName: style.name, success: true });
          console.log(`Successfully generated style: ${style.name}`);
        } catch (error) {
          results.push({
            styleName: style.name,
            success: false,
            error: error.message
          });
          console.error(`Failed to generate style ${style.name}:`, error);
        }
      }
      notice.hide();
      const successCount = results.filter((r) => r.success).length;
      new import_obsidian5.Notice(`\u5B8C\u6210\uFF01\u6210\u529F\u751F\u6210 ${successCount}/${results.length} \u79CD\u98CE\u683C\u7684\u56FE\u7247`);
      console.log("Magazine style generation results:", results);
    } catch (error) {
      notice.hide();
      new import_obsidian5.Notice(`\u6D4B\u8BD5\u5931\u8D25: ${error.message}`);
      console.error("Test all styles error:", error);
    }
  }
  async generateSpecificStyle(file, styleId) {
    const content = await this.app.vault.read(file);
    const parsedContent = ContentParser.parseMarkdownContent(content, file.name);
    return this.imageGenerator.generateWithStyle(
      parsedContent.title,
      parsedContent.content,
      styleId
    );
  }
  async publishNote(file, customOptions, postToTwitter) {
    if (!this.settings.apiUrl || !this.settings.apiKey) {
      new import_obsidian5.Notice("Please configure API URL and API Key in settings");
      return;
    }
    const publishNotice = new import_obsidian5.Notice("Publishing to Microfeed...", 0);
    try {
      const content = await this.app.vault.read(file);
      const parsedContent = ContentParser.parseMarkdownContent(content, file.name);
      const client = new MicrofeedClient(this.settings.apiUrl, this.settings.apiKey);
      const item = await this.buildMicrofeedItem(parsedContent, client, file, customOptions);
      const result = await client.createItem(item);
      const itemUrl = `${this.settings.apiUrl}/items/${result.id}`;
      let twitterResult = null;
      const shouldPostToTwitter = postToTwitter != null ? postToTwitter : this.settings.twitter.enabled && this.settings.twitter.autoPost;
      if (shouldPostToTwitter) {
        try {
          const twitterClient = new TwitterClient(this.settings.twitter);
          if (twitterClient.isConfigured()) {
            const tweetText = twitterClient.formatTweetText(
              item.title,
              itemUrl,
              parsedContent.content.substring(0, 200)
            );
            twitterResult = await twitterClient.postTweet(tweetText);
            new import_obsidian5.Notice("\u{1F4F1} Posted to Twitter/X!");
          } else {
            new import_obsidian5.Notice("\u26A0\uFE0F Twitter credentials not configured correctly");
          }
        } catch (twitterError) {
          console.error("Twitter posting error:", twitterError);
          new import_obsidian5.Notice(`\u26A0\uFE0F Posted to Microfeed but failed to post to Twitter: ${twitterError.message}`);
        }
      }
      publishNotice.hide();
      new import_obsidian5.Notice("\u2705 Successfully published to Microfeed!");
      console.log("Published item:", result);
      if (twitterResult) {
        console.log("Twitter post:", twitterResult);
      }
    } catch (error) {
      publishNotice.hide();
      new import_obsidian5.Notice(`\u274C Failed to publish: ${error.message}`);
      console.error("Publish error:", error);
    }
  }
  async buildMicrofeedItem(parsedContent, client, file, customOptions) {
    var _a;
    const item = {
      title: parsedContent.title,
      status: (customOptions == null ? void 0 : customOptions.status) || parsedContent.frontMatter.status || this.settings.defaultStatus,
      content_html: this.markdownToHtml(parsedContent.content),
      date_published_ms: Date.now()
    };
    const mainAttachment = ContentParser.selectMainAttachment(parsedContent.mediaFiles);
    if (mainAttachment) {
      await this.processMainAttachment(item, mainAttachment, client, file);
      if (mainAttachment.type === "image" && ((_a = item.attachment) == null ? void 0 : _a.url)) {
        item.image = item.attachment.url;
        console.log("\u{1F4F8} Using main attachment image as item image");
      }
    }
    await this.processDocumentImages(item, parsedContent, client, file);
    if (!item.image && this.settings.autoGenerateImage) {
      await this.generateAndUploadImage(item, parsedContent, client);
    }
    if (Object.keys(parsedContent.frontMatter).some((key) => key.startsWith("itunes:"))) {
      item._microfeed = {};
      const itunesFields = [
        "itunes:title",
        "itunes:block",
        "itunes:episodeType",
        "itunes:season",
        "itunes:episode",
        "itunes:explicit"
      ];
      for (const field of itunesFields) {
        if (parsedContent.frontMatter[field] !== void 0) {
          item._microfeed[field] = parsedContent.frontMatter[field];
        }
      }
    }
    if (customOptions) {
      Object.assign(item, customOptions);
    }
    return item;
  }
  async processMainAttachment(item, mediaFile, client, file) {
    if (mediaFile.type === "external_url") {
      item.attachment = {
        category: "external_url",
        url: mediaFile.url
      };
      return;
    }
    const mediaPath = this.resolveMediaPath(mediaFile.url, file);
    const mediaFile_obj = await this.getFileFromPath(mediaPath);
    if (mediaFile_obj) {
      const fileName = mediaFile_obj.name;
      const mediaUrl = await client.uploadMediaFile(
        await this.app.vault.readBinary(mediaFile_obj),
        mediaFile.type,
        fileName
      );
      item.attachment = {
        category: mediaFile.type,
        url: mediaUrl,
        mime_type: client.getMimeType(fileName, mediaFile.type),
        size_in_bytes: (await this.app.vault.readBinary(mediaFile_obj)).byteLength
      };
      if (mediaFile.type === "audio" || mediaFile.type === "video") {
        const blob = new Blob([await this.app.vault.readBinary(mediaFile_obj)]);
        const duration = await client.getMediaDuration(new File([blob], fileName));
        if (duration) {
          item.attachment.duration_in_seconds = duration;
        }
      }
    }
  }
  async processDocumentImages(item, parsedContent, client, file) {
    const imageFiles = parsedContent.mediaFiles.filter((f) => f.type === "image");
    if (imageFiles.length > 0 && !item.image) {
      const firstImage = imageFiles[0];
      if (firstImage.type === "external_url") {
        item.image = firstImage.url;
        console.log("\u{1F5BC}\uFE0F Using external image as item image:", firstImage.url);
      } else {
        const mediaPath = this.resolveMediaPath(firstImage.url, file);
        const mediaFile_obj = await this.getFileFromPath(mediaPath);
        if (mediaFile_obj) {
          try {
            console.log("\u{1F4E4} Uploading document image to R2...");
            const fileName = mediaFile_obj.name;
            const mediaUrl = await client.uploadMediaFile(
              await this.app.vault.readBinary(mediaFile_obj),
              "image",
              fileName
            );
            item.image = mediaUrl;
            console.log("\u2705 Successfully uploaded document image:", mediaUrl);
          } catch (error) {
            console.warn("\u26A0\uFE0F Failed to upload document image:", error);
          }
        }
      }
    }
    await this.processContentImages(item, parsedContent, client, file);
  }
  async processContentImages(item, parsedContent, client, file) {
    const localImages = parsedContent.mediaFiles.filter(
      (f) => f.type === "image" && !f.url.startsWith("http")
    );
    if (localImages.length === 0) {
      return;
    }
    console.log(`\u{1F4F7} Found ${localImages.length} local images to process in content`);
    let updatedContent = item.content_html || "";
    for (const imageFile of localImages) {
      const mediaPath = this.resolveMediaPath(imageFile.url, file);
      const mediaFile_obj = await this.getFileFromPath(mediaPath);
      if (mediaFile_obj) {
        try {
          const fileName = mediaFile_obj.name;
          const mediaUrl = await client.uploadMediaFile(
            await this.app.vault.readBinary(mediaFile_obj),
            "image",
            fileName
          );
          updatedContent = updatedContent.replace(
            new RegExp(this.escapeRegExp(imageFile.url), "g"),
            mediaUrl
          );
          console.log(`\u2705 Replaced image ${imageFile.url} with ${mediaUrl}`);
        } catch (error) {
          console.warn(`\u26A0\uFE0F Failed to upload content image ${imageFile.url}:`, error);
        }
      }
    }
    item.content_html = updatedContent;
  }
  escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  async generateAndUploadImage(item, parsedContent, client) {
    try {
      console.log("\u{1F3A8} Starting magazine-style image generation with QR code...");
      console.log(`\u{1F4DD} Title: ${parsedContent.title.substring(0, 50)}...`);
      const imageBlob = await this.imageGenerator.generateRandomStyle(
        parsedContent.title,
        parsedContent.content
      );
      const fileName = `magazine-style-${Date.now()}.png`;
      const imageUrl = await client.uploadMediaFile(imageBlob, "image", fileName);
      item.image = imageUrl;
      console.log("\u2705 Successfully generated and uploaded magazine-style image with QR code");
      console.log(`\u{1F4F8} Image URL: ${imageUrl}`);
    } catch (error) {
      console.warn("\u26A0\uFE0F Magazine-style generation failed, trying fallback:", error);
      try {
        console.log("\u{1F504} Using fallback image generation (Bento style)...");
        const imageBlob = await this.imageGenerator.generateThumbnail(
          parsedContent.title,
          parsedContent.content
        );
        const fileName = `fallback-${Date.now()}.png`;
        const imageUrl = await client.uploadMediaFile(imageBlob, "image", fileName);
        item.image = imageUrl;
        console.log("\u2705 Fallback image generation successful");
        console.log(`\u{1F4F8} Fallback Image URL: ${imageUrl}`);
      } catch (fallbackError) {
        console.error("\u274C Both magazine-style and fallback image generation failed:", fallbackError);
        console.error("\u{1F4CB} Error details:", fallbackError.message);
      }
    }
  }
  resolveMediaPath(mediaUrl, currentFile) {
    var _a;
    if (mediaUrl.startsWith("http")) {
      return mediaUrl;
    }
    const currentDir = ((_a = currentFile.parent) == null ? void 0 : _a.path) || "";
    if (mediaUrl.startsWith("./")) {
      return `${currentDir}/${mediaUrl.slice(2)}`;
    } else if (mediaUrl.startsWith("../")) {
      const parts = currentDir.split("/");
      const urlParts = mediaUrl.split("/");
      let i = 0;
      while (urlParts[i] === ".." && i < urlParts.length) {
        parts.pop();
        i++;
      }
      return `${parts.join("/")}/${urlParts.slice(i).join("/")}`;
    } else {
      return mediaUrl;
    }
  }
  async getFileFromPath(path) {
    if (path.startsWith("http")) {
      return null;
    }
    const file = this.app.vault.getAbstractFileByPath(path);
    return file instanceof import_obsidian5.TFile ? file : null;
  }
  markdownToHtml(markdown) {
    return markdown.replace(/^### (.*$)/gim, "<h3>$1</h3>").replace(/^## (.*$)/gim, "<h2>$1</h2>").replace(/^# (.*$)/gim, "<h1>$1</h1>").replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>").replace(/\*(.*?)\*/g, "<em>$1</em>").replace(/`(.*?)`/g, "<code>$1</code>").replace(/\n\n/g, "</p><p>").replace(/^(.+)$/gm, "<p>$1</p>").replace(/<p><h([1-6])>/g, "<h$1>").replace(/<\/h([1-6])><\/p>/g, "</h$1>");
  }
  async postToTwitter() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (!activeView) {
      new import_obsidian5.Notice("No active markdown note found");
      return;
    }
    const file = activeView.file;
    if (!file) {
      new import_obsidian5.Notice("No file found");
      return;
    }
    if (!this.settings.twitter.enabled || !this.settings.twitter.bearerToken) {
      new import_obsidian5.Notice("Twitter/X integration is not configured. Please check your settings.");
      return;
    }
    const notice = new import_obsidian5.Notice("Posting to Twitter/X...", 0);
    try {
      const content = await this.app.vault.read(file);
      const parsedContent = ContentParser.parseMarkdownContent(content, file.name);
      const twitterClient = new TwitterClient(this.settings.twitter);
      const tweetText = twitterClient.formatTweetText(
        parsedContent.title,
        "",
        // No Microfeed URL for Twitter-only posts
        parsedContent.content.substring(0, 200)
      );
      await twitterClient.postTweet(tweetText);
      notice.hide();
      new import_obsidian5.Notice("\u{1F4F1} Successfully posted to Twitter/X!");
    } catch (error) {
      notice.hide();
      new import_obsidian5.Notice(`\u274C Failed to post to Twitter: ${error.message}`);
      console.error("Twitter posting error:", error);
    }
  }
  async publishToMicrofeedAndTwitter() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (!activeView) {
      new import_obsidian5.Notice("No active markdown note found");
      return;
    }
    const file = activeView.file;
    if (!file) {
      new import_obsidian5.Notice("No file found");
      return;
    }
    await this.publishNote(file, void 0, true);
  }
};
var PublishOptionsModal = class extends import_obsidian5.Modal {
  constructor(app, plugin, file) {
    super(app);
    this.status = "published";
    this.postToTwitter = false;
    this.plugin = plugin;
    this.file = file;
    this.status = plugin.settings.defaultStatus;
    this.postToTwitter = plugin.settings.twitter.enabled && plugin.settings.twitter.autoPost;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Publish Options" });
    const statusContainer = contentEl.createDiv();
    statusContainer.createEl("label", { text: "Publication Status:" });
    const statusSelect = statusContainer.createEl("select");
    ["published", "unlisted", "unpublished"].forEach((status) => {
      const option = statusSelect.createEl("option", {
        text: status.charAt(0).toUpperCase() + status.slice(1),
        value: status
      });
      if (status === this.status) {
        option.selected = true;
      }
    });
    statusSelect.addEventListener("change", (e) => {
      this.status = e.target.value;
    });
    if (this.plugin.settings.twitter.enabled) {
      const twitterContainer = contentEl.createDiv();
      twitterContainer.createEl("label", { text: "Post to Twitter/X:" });
      const twitterToggle = twitterContainer.createEl("input", {
        type: "checkbox",
        cls: "checkbox"
      });
      twitterToggle.checked = this.postToTwitter;
      twitterToggle.addEventListener("change", (e) => {
        this.postToTwitter = e.target.checked;
      });
    }
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => this.close());
    const publishButton = buttonContainer.createEl("button", {
      text: "Publish",
      cls: "mod-cta"
    });
    publishButton.addEventListener("click", async () => {
      this.close();
      await this.plugin.publishNote(this.file, { status: this.status }, this.postToTwitter);
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var MagazineStyleModal = class extends import_obsidian5.Modal {
  constructor(app, plugin, file) {
    super(app);
    this.selectedStyleId = "";
    this.plugin = plugin;
    this.file = file;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("magazine-style-modal");
    contentEl.createEl("h2", { text: "\u6742\u5FD7\u98CE\u683C\u9884\u89C8\u5668" });
    contentEl.createEl("p", { text: "\u9009\u62E9\u4E00\u79CD\u8BBE\u8BA1\u98CE\u683C\u6765\u9884\u89C8\u60A8\u7684\u5185\u5BB9" });
    const selectorContainer = contentEl.createDiv({ cls: "style-selector-container" });
    selectorContainer.createEl("label", { text: "\u9009\u62E9\u8BBE\u8BA1\u98CE\u683C:" });
    const styleSelect = selectorContainer.createEl("select", { cls: "style-select" });
    const randomOption = styleSelect.createEl("option", {
      text: "\u{1F3B2} \u968F\u673A\u98CE\u683C",
      value: "random"
    });
    randomOption.selected = true;
    const styles = this.plugin.imageGenerator.getAvailableStyles();
    styles.forEach((style2) => {
      styleSelect.createEl("option", {
        text: `${this.getStyleEmoji(style2.id)} ${style2.name}`,
        value: style2.id
      });
    });
    styleSelect.addEventListener("change", (e) => {
      this.selectedStyleId = e.target.value;
    });
    this.previewContainer = contentEl.createDiv({ cls: "preview-container" });
    this.previewContainer.innerHTML = '<p>\u70B9\u51FB"\u751F\u6210\u9884\u89C8"\u6765\u67E5\u770B\u6548\u679C</p>';
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const previewButton = buttonContainer.createEl("button", {
      text: "\u751F\u6210\u9884\u89C8",
      cls: "mod-cta"
    });
    previewButton.addEventListener("click", () => this.generatePreview());
    const randomButton = buttonContainer.createEl("button", { text: "\u968F\u673A\u751F\u6210" });
    randomButton.addEventListener("click", () => {
      styleSelect.value = "random";
      this.selectedStyleId = "random";
      this.generatePreview();
    });
    const closeButton = buttonContainer.createEl("button", { text: "\u5173\u95ED" });
    closeButton.addEventListener("click", () => this.close());
    const style = document.createElement("style");
    style.textContent = `
      .magazine-style-modal {
        min-width: 600px;
        max-width: 800px;
      }
      .style-selector-container {
        margin: 20px 0;
      }
      .style-select {
        width: 100%;
        padding: 8px;
        margin-top: 5px;
        border-radius: 4px;
        border: 1px solid var(--background-modifier-border);
      }
      .preview-container {
        margin: 20px 0;
        padding: 20px;
        border: 1px solid var(--background-modifier-border);
        border-radius: 8px;
        min-height: 200px;
        background: var(--background-secondary);
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
      }
      .preview-image {
        max-width: 100%;
        max-height: 400px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      }
      .modal-button-container {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }
      .loading-spinner {
        border: 3px solid var(--background-modifier-border);
        border-top: 3px solid var(--interactive-accent);
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
        margin: 0 auto;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    `;
    document.head.appendChild(style);
  }
  getStyleEmoji(styleId) {
    const emojiMap = {
      "minimalist": "\u26AA",
      "bold-modern": "\u26A1",
      "elegant-vintage": "\u{1F3AD}",
      "futuristic-tech": "\u{1F680}",
      "scandinavian": "\u2744\uFE0F",
      "art-deco": "\u{1F48E}",
      "japanese-minimalism": "\u{1F38B}",
      "postmodern-deconstruction": "\u{1F9E9}",
      "punk": "\u{1F3B8}",
      "british-rock": "\u{1F1EC}\u{1F1E7}",
      "black-metal": "\u26AB",
      "memphis-design": "\u{1F308}",
      "cyberpunk": "\u{1F52E}",
      "pop-art": "\u{1F3A8}",
      "deconstructed-swiss": "\u{1F3D4}\uFE0F",
      "vaporwave": "\u{1F338}",
      "neo-expressionism": "\u{1F3AD}",
      "extreme-minimalism": "\u2B1C",
      "neo-futurism": "\u2728",
      "surrealist-collage": "\u{1F3AA}",
      "neo-baroque": "\u{1F451}",
      "liquid-morphism": "\u{1F4A7}",
      "hypersensory-minimalism": "\u{1F50D}",
      "neo-expressionist-data": "\u{1F4CA}",
      "victorian": "\u{1F3DB}\uFE0F",
      "bauhaus": "\u{1F53A}",
      "constructivism": "\u{1F534}",
      "german-expressionism": "\u{1F3AC}"
    };
    return emojiMap[styleId] || "\u{1F3A8}";
  }
  async generatePreview() {
    const loadingEl = this.previewContainer;
    loadingEl.innerHTML = '<div class="loading-spinner"></div><p>\u6B63\u5728\u751F\u6210\u9884\u89C8...</p>';
    try {
      const styleId = this.selectedStyleId === "random" ? void 0 : this.selectedStyleId;
      const imageBlob = await this.plugin.generateSpecificStyle(this.file, styleId || "");
      const reader = new FileReader();
      reader.onload = (e) => {
        var _a;
        const imageUrl = (_a = e.target) == null ? void 0 : _a.result;
        loadingEl.innerHTML = `
          <img src="${imageUrl}" alt="Magazine Style Preview" class="preview-image" />
          <div style="margin-top: 10px; font-size: 12px; color: var(--text-muted);">
            \u98CE\u683C: ${this.getSelectedStyleName()}
          </div>
        `;
      };
      reader.readAsDataURL(imageBlob);
    } catch (error) {
      loadingEl.innerHTML = `<p style="color: var(--text-error);">\u751F\u6210\u9884\u89C8\u5931\u8D25: ${error.message}</p>`;
      console.error("Preview generation failed:", error);
    }
  }
  getSelectedStyleName() {
    if (this.selectedStyleId === "random" || !this.selectedStyleId) {
      return "\u968F\u673A\u98CE\u683C";
    }
    const styles = this.plugin.imageGenerator.getAvailableStyles();
    const style = styles.find((s) => s.id === this.selectedStyleId);
    return style ? style.name : "\u672A\u77E5\u98CE\u683C";
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    const styleEl = document.querySelector("style[data-magazine-modal]");
    if (styleEl) {
      styleEl.remove();
    }
  }
};
